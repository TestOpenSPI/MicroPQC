#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#include "axiocrypto_pqc.h"
#include "axiocrypto_pqc_example.h"
#include "FreeRTOS.h"
#include "task.h"

/* Provided hex vectors for smaug1 */
static const char *hex_pk_vec[] = {
     "ABB274A92ACEE034D3BAEE5C7BFAEDC2A7FAAAC404F37C9A3B15BCB3CFF808039F7DD5BDD9655DB8963645CD84ED1C20D63A2C2AFDD1F0235EB50177875B380D2362084330D9BC00C7726F6AD60A0ABDFC97E90DB444997B9FFAEA5F124AFC0CAF584331AC7B840E78FACCBDBDC3D8E6D39E5E7EA455D7D36B9EF4AE04A3CF2A0EADB6701AFA1E94B2B2AF1A0DBCB21D6653002883A6A8C2AE7D90DAD7F4C5E15930FE244CABDC104F4C662673092A0E98907EC4F0B27D63B98584F4DB0CE757A55D5AEB0557B1B31674E945B3CDE0BD83AB6E8C9DA0A4F9CE66293F693C32084272313CEC7AFB22DC39429F2320F39E998EF419A34509835C3DA590C64514AB39F0399D918605E12F1698018065E823C8CA3800A51023421A00D46831FD1E01156C7661A2C1EA777A486AA7D7C91481F7996CBA1B0840E9600A4368FF740C610754FF6E3A2CFD7EE7E66FED45C126C3E58E1B5260F6CA70CD70BCF70278C807084BF2142752BDA9F3B8EEE618A36A5A13AD52325C0B3C96410420344618763B4A3B6BA7F400AC424848C5FF2798BE48CD50896B161E99C0586B4A7F002D816209879F4C9ADD5BE100F41239614796FD8A08ABE8791E9CD393F46511E75C12276B906CB5E9DB888C59D67DEB6FA612E9BC49C6D73EB23FC86E50BB9062071F33040CD4FCB25447ED614E0A85AD9C505F98CBDD76F1A0DCCF6114BC638718DD8D66E9F7B1D204EE5F44306342E7BBEFAC11B6418832E33970EDE8566A150F9E587BC76F5865E1251CB5478AC53164F9FC31935B621D5D979B9B81FB7C5E033FCFB0AEEF057CF0E9F384D2B9EE5F4BE5B62670DE9803FBF5AB2D23D2AB5A1F1EFCAA259C9ED575D19E4481E08137F85515F1DCCC3FFF7197B03D2C1E70C87F287998DA1A41F68FFA0B443E0DA903CCC11FC3A60593F61074388D347EACB86BE82F",
     "61BB470760DAB9BEE525B7EAA67809C438779B783A73FFA391872B4A3A9D12046DBA06789F90FD252C7F468C659F5D1357C1D9E3890070C6DE4817B9900DF329ED3AD748C5FECC77609AB5BEDB680A5FAE61D190388611002347BF7BD2C7A5009D479B2C4E8006665E22B96C8D32D265F630C62032A6D27D811F0B6969371E323B305BF93628D42FD00E9C5E5A62076FA57EA0585AA21EB0B6E7A1E01A45096461D9A9483CC0EB2DD28247BAFB23A121BB12E5819A633160F9D1102177A240BE578A0CA5C30D09B0170B4B7ECE20E8EFF82A0473E9EF7A4AD611DF01F34758D35661AB9F3E6767315CA476A2110A8E89CB57877842A52E69EE7C6B037FA6A2C47D57B2FF46E72F1BC39CF21A943F4817BB0420A1A1E024B04E0C979CC80BFA6618EC140D24C035C74786D24AC6DDAFF8F090BA6AFECC275B7BEE6675162694C61F39D472A02637EB1743AF44EFFB75DFCFB34E1514A94A21A233FA9DF905B08E6E1A9F748CFCE32960E05E76AB8EC9894064AFADC4B2018DDB57D92800BF043297A4E861996C54025DC519B48D92AC444A84DB663FDD40DB9891858400E6C165A1A1AE1C43B99E65D76520488B406AD84F05421572C5232B734BA94884878BB8E56FADABFB48CD7E27DB86310501636C6B0CA6C4DC153CACEB64AD4A77B7DAF1A6E84F98A53294E50B5696D0DFB8FD8564B5D13B80A15E4198871B134A815F0ECE20CF88E3989543A886B356413C5B046377331199A32C83A96A648F9B08D8B5E1D81870E24E91E7D7CABA7A7540161DA6BFFD7D1B9D161F08A238A36F4CCBCADD7A0795B406EB20F21AA1D71794E464E365E53ECA7861DE85C5051F0A036E6C15A015F7FA9C144582AB261A7A3EB3F21E6FCED0029740118B574F7A3938632D7A2C24147A3A23F5D0C2F25E6B9FBE90A688E1A9AD6C6F85979441F87F6B90F8"
};

static const char *hex_sk_vec[] = {
     "C33051353CC00000000300C5DC000045000F00003F00D000000040000F0300414D40CC0003000430130044000C05000300000400000011D00CF0C0050D51003110C33C500C41010000000FC0C0000F1404400005400C0005400C00000C4550340400450D000400031440C30301000C100004000CC14100D0C30004CC030004018626ED79D451140800E03B59B956F8210E556067407D13DC90FA9E8B872BFB8FABB274A92ACEE034D3BAEE5C7BFAEDC2A7FAAAC404F37C9A3B15BCB3CFF808039F7DD5BDD9655DB8963645CD84ED1C20D63A2C2AFDD1F0235EB50177875B380D2362084330D9BC00C7726F6AD60A0ABDFC97E90DB444997B9FFAEA5F124AFC0CAF584331AC7B840E78FACCBDBDC3D8E6D39E5E7EA455D7D36B9EF4AE04A3CF2A0EADB6701AFA1E94B2B2AF1A0DBCB21D6653002883A6A8C2AE7D90DAD7F4C5E15930FE244CABDC104F4C662673092A0E98907EC4F0B27D63B98584F4DB0CE757A55D5AEB0557B1B31674E945B3CDE0BD83AB6E8C9DA0A4F9CE66293F693C32084272313CEC7AFB22DC39429F2320F39E998EF419A34509835C3DA590C64514AB39F0399D918605E12F1698018065E823C8CA3800A51023421A00D46831FD1E01156C7661A2C1EA777A486AA7D7C91481F7996CBA1B0840E9600A4368FF740C610754FF6E3A2CFD7EE7E66FED45C126C3E58E1B5260F6CA70CD70BCF70278C807084BF2142752BDA9F3B8EEE618A36A5A13AD52325C0B3C96410420344618763B4A3B6BA7F400AC424848C5FF2798BE48CD50896B161E99C0586B4A7F002D816209879F4C9ADD5BE100F41239614796FD8A08ABE8791E9CD393F46511E75C12276B906CB5E9DB888C59D67DEB6FA612E9BC49C6D73EB23FC86E50BB9062071F33040CD4FCB25447ED614E0A85AD9C505F98CBDD76F1A0DCCF6114BC638718DD8D66E9F7B1D204EE5F44306342E7BBEFAC11B6418832E33970EDE8566A150F9E587BC76F5865E1251CB5478AC53164F9FC31935B621D5D979B9B81FB7C5E033FCFB0AEEF057CF0E9F384D2B9EE5F4BE5B62670DE9803FBF5AB2D23D2AB5A1F1EFCAA259C9ED575D19E4481E08137F85515F1DCCC3FFF7197B03D2C1E70C87F287998DA1A41F68FFA0B443E0DA903CCC11FC3A60593F61074388D347EACB86BE82F",
     "00C4030304140404400004001044301C7F0410011000D03C033300F014011C0011333000F00000040440F030F44000000CCC030000400000011407400C0001040C3130C3C000C4130030400100001F00044410D00C01140004030001C4C103F304100400C050C0404F000000F100004000C131030D30005000001C0000C150C0003271531CF27285B8721ED5CB46853043B346A66CBA6CF765F1B0EAA40BF67261BB470760DAB9BEE525B7EAA67809C438779B783A73FFA391872B4A3A9D12046DBA06789F90FD252C7F468C659F5D1357C1D9E3890070C6DE4817B9900DF329ED3AD748C5FECC77609AB5BEDB680A5FAE61D190388611002347BF7BD2C7A5009D479B2C4E8006665E22B96C8D32D265F630C62032A6D27D811F0B6969371E323B305BF93628D42FD00E9C5E5A62076FA57EA0585AA21EB0B6E7A1E01A45096461D9A9483CC0EB2DD28247BAFB23A121BB12E5819A633160F9D1102177A240BE578A0CA5C30D09B0170B4B7ECE20E8EFF82A0473E9EF7A4AD611DF01F34758D35661AB9F3E6767315CA476A2110A8E89CB57877842A52E69EE7C6B037FA6A2C47D57B2FF46E72F1BC39CF21A943F4817BB0420A1A1E024B04E0C979CC80BFA6618EC140D24C035C74786D24AC6DDAFF8F090BA6AFECC275B7BEE6675162694C61F39D472A02637EB1743AF44EFFB75DFCFB34E1514A94A21A233FA9DF905B08E6E1A9F748CFCE32960E05E76AB8EC9894064AFADC4B2018DDB57D92800BF043297A4E861996C54025DC519B48D92AC444A84DB663FDD40DB9891858400E6C165A1A1AE1C43B99E65D76520488B406AD84F05421572C5232B734BA94884878BB8E56FADABFB48CD7E27DB86310501636C6B0CA6C4DC153CACEB64AD4A77B7DAF1A6E84F98A53294E50B5696D0DFB8FD8564B5D13B80A15E4198871B134A815F0ECE20CF88E3989543A886B356413C5B046377331199A32C83A96A648F9B08D8B5E1D81870E24E91E7D7CABA7A7540161DA6BFFD7D1B9D161F08A238A36F4CCBCADD7A0795B406EB20F21AA1D71794E464E365E53ECA7861DE85C5051F0A036E6C15A015F7FA9C144582AB261A7A3EB3F21E6FCED0029740118B574F7A3938632D7A2C24147A3A23F5D0C2F25E6B9FBE90A688E1A9AD6C6F85979441F87F6B90F8"
};

static const char *hex_ct_vec[] = {
     "60EDFC51D6D72BC752D065B3844DDC66D20295A7091F792B01E5D91B5BDFF5B1A46F96C0C583C441B2AC5C94F1825AF583BC72067ACC6EA1112FC5C57CE4736015CE1D06077D17CD52326C23BFD6A0FAF7D8DD76A91AE9EB633090B47E52BF88EF2223FFB08B662B1A9AEA38A58CDD7CA52AB681AD2C407451425C29570ADBD79D2B34DA7C50CAEB5898BB4AB4D5449EA76D26116F5B081300C85D354512609312759CCA30C58C01165992A01F75B502A58BF582E60A35423E96C7B64DF2C013A4CD8A1A56C5D9C15E0D335DE62683043838F4CDE2DCE17B2614D4E95B711FD136D891D5A49B3F4929936614D983AC85D93C11FEE78EF85C5BAE10EC785DD829938BC81000235B01758CA0F8127FEFD022DA8187E0E7B4A62944DBD3B0A3124C46A9F6F5A89AA02FE129411743BE85B447CAB8CD1269C7AF368F81567EDE84EA2FD2DCA61CC57FFFCA6607E463EE601BEDAB7D5B57EB4FCB865410A3DA0CDC4100DA434D1534A6B808F8558C272550554B0EDC248D425E4EEC531B17077FFBFE42CC7C6B615746DD8466DD0DC237390BD615FB3E8D30E10BAFAC52A54E1C0AEBDB6E521BA1AAD1478BDFEF6DD8C0DA5CA978E1FD2B19D32306F3DA5AEAB77C768C0A38626EBD1BC7EF1A86F496602ED6399C4BED3FCA49F082E00AED3F113A6D53B31F7A82765F924495C719AA72F4615BB77F099A3A760B49117C6E8A26583173DDE0D73B9E275205D5250F1C8361FB1173B2F731E02A20DB38C547A177EAE0DA362AD80DBCC6F2771D360BC8ABB49D68103EC26F6F0853457A8343B918555349D13D6B43200EC5B5D87D0C6EDB17A170F8FEF58B429F445E3901DA60945D4D80180603179B297BAB8C9DD01738FD16E1884C27E7BC24E66E37DB591D25E722B381196ED37A504677CD2EE692522BD394E81D8D6F122439F70CE9108B061C41",
     "AB8CB40B1948964B407DEFDEAB65490624C9EA1D0231D5C85194626C6E7D88FCCAD897E81172E3FA46DA631E9664C8013C24F268CC698FDE9C6823F6351418E92475D3CFC8B671D4265142BFCA04F01EFCC719DFDA6D745B3A7E4A31864C82662B6EF6AC89F3E46770FA6179CB77752B9246262C555D35572A2870235B050E52C2DBFB549C995AEBE759F0EED609013FF5799EADA0E8E22E8DCD49D76CF1FA587B7AD3C8768FFF7A7E81583804DF30BE3B17A1DABBFC12F8B14CAF9D60F1E5F802EAA7AB1A3BD783836EB22ABDC35D513A10FD2A0A36C5B8DB2E55C62FF97FD0358F4C1847C00C794B52BBE62CBBB72B60D20C8F274CDC98B7B229526538C5B9C5D31E9766FA63B379B16B8B6C3767569780E4EB34A55C469E5C669A0E53580B882AC0B71550FB0734CFBC07FD28B5726DE135BA49875C23DEAEF8E6F8DFEF4DF96A2BFFE9DAB376A0025CDADCDF7739856B9C8C74FA1F2E10A574451154AC465ED839C393D6D72480C6AE6E71281D39E0631881CF3FEDF7359D936FECC7A02ABE440D51331DDB98C94CE7E8FB91CB172003FB389025D423167F7C199C6AF64A7293622D43A8849B2D51C5E269ECAB060B86494BD9473E25E545786C205FDE751731B644819B29E7C82B5C041F6949E8BD71B19E39334656743D72DCBECE9218E717AD4ED2A88C9C959C2B3A8A91D3CC443D5C9BDC839797D36D8A8C2CCA8577F0D9B3245EB639DB2952E309F4A9C0F1ED393CC91C4D431A73801D3135EFF30B9E54A679231FA53C545F9C1E3373A3E53A636899A016D330C377FAC09E33344C87A509DF97A2431E9173C2AE5039677439BD3313CB1313C54AA499A6189A8CF2BA71959181B86F06FBD13454F0FF3218F24C681B9F9A617A33B5F7EA89C842DE03643A178902F3C0FE851508F67E441135D224532EC81C3469E8D9F8A5CB5FA7"
};

static const char *hex_ss_vec[] = {
     "A07B06F41EC82A93AF483718CEE955551A67D103977B195DF92EC28A547E93AD",
     "05D28193FB233DD20E9D0143B8A4C6AF534C97C509D986511986033D5B8A83EC"
};

int axiocrypto_pqc_smaug1_kat(void)
{
     int ret = -1;
     size_t i = 0;
     size_t failures = 0;

     const size_t n_pk = ARRAY_LEN(hex_pk_vec);
     const size_t n_sk = ARRAY_LEN(hex_sk_vec);
     const size_t n_ct = ARRAY_LEN(hex_ct_vec);
     const size_t n_ss = ARRAY_LEN(hex_ss_vec);

     uint8_t *pk = NULL, *sk = NULL, *ct = NULL, *ss = NULL;
     uint8_t *ss_out = NULL, *decap_ss = NULL, *encap_ct = NULL;

     size_t encap_ct_len = 0;
     size_t decap_ss_len = 0;

     printf("================================================================================\n");
     /* 배열 정합성 체크 */
     if (n_pk == 0 || n_pk != n_sk || n_pk != n_ct || n_pk != n_ss) {
          printf("FAIL [INIT] vector count mismatch: pk=%u sk=%u ct=%u ss=%u\n",
                    n_pk, n_sk, n_ct, n_ss);
          return -1;
     }

     pk = (uint8_t*)malloc(PQC_SMAUG1_PUBLICKEY_SIZE);
     if(pk == NULL) {
          printf("FAIL [INIT] pk malloc failed\n");
          ret = -1;
          goto cleanup;
     }
     sk = (uint8_t*)malloc(PQC_SMAUG1_SECRETKEY_SIZE);
     if(sk == NULL) {
          printf("FAIL [INIT] sk malloc failed\n");
          ret = -1;
          goto cleanup;
     }
     ct = (uint8_t*)malloc(PQC_SMAUG1_CIPHERTEXT_SIZE);
     if(ct == NULL) {
          printf("FAIL [INIT] ct malloc failed\n");
          ret = -1;
          goto cleanup;
     }
     ss = (uint8_t*)malloc(PQC_SMAUG1_SHAREDSECRET_SIZE);
     if(ss == NULL) {
          printf("FAIL [INIT] ss malloc failed\n");
          ret = -1;
          goto cleanup;
     }
     ss_out  = (uint8_t*)malloc(PQC_SMAUG1_SHAREDSECRET_SIZE);
     if(ss_out == NULL) {
          printf("FAIL [INIT] ss_out malloc failed\n");
          ret = -1;
          goto cleanup;
     }
     encap_ct= (uint8_t*)malloc(PQC_SMAUG1_CIPHERTEXT_SIZE);
     if(encap_ct == NULL) {
          printf("FAIL [INIT] encap_ct malloc failed\n");
          ret = -1;
          goto cleanup;
     }
     decap_ss= (uint8_t*)malloc(PQC_SMAUG1_SHAREDSECRET_SIZE);
     if(decap_ss == NULL) {
          printf("FAIL [INIT] decap_ss malloc failed\n");
          ret = -1;
          goto cleanup;
     }

     for (i = 0; i < n_pk; i++) {
          /* 출력버퍼 초기화 */
          memset(ss_out,   0, PQC_SMAUG1_SHAREDSECRET_SIZE);
          memset(decap_ss, 0, PQC_SMAUG1_SHAREDSECRET_SIZE);
          memset(encap_ct, 0, PQC_SMAUG1_CIPHERTEXT_SIZE);

          /* 벡터 파싱 */
          if (hexTobin(hex_pk_vec[i], pk, PQC_SMAUG1_PUBLICKEY_SIZE) != (int)PQC_SMAUG1_PUBLICKEY_SIZE) {
               printf("FAIL [#%02u][INIT] pk hex parse/size mismatch\n", i);
               failures++;
               continue;
          }
          if (hexTobin(hex_sk_vec[i], sk, PQC_SMAUG1_SECRETKEY_SIZE) != (int)PQC_SMAUG1_SECRETKEY_SIZE) {
               printf("FAIL [#%02u][INIT] sk hex parse/size mismatch\n", i);
               failures++;
               continue;
          }
          if (hexTobin(hex_ct_vec[i], ct, PQC_SMAUG1_CIPHERTEXT_SIZE) != (int)PQC_SMAUG1_CIPHERTEXT_SIZE) {
               printf("FAIL [#%02u][INIT] ct hex parse/size mismatch\n", i);
               failures++;
               continue;
          }
          if (hexTobin(hex_ss_vec[i], ss, PQC_SMAUG1_SHAREDSECRET_SIZE) != (int)PQC_SMAUG1_SHAREDSECRET_SIZE) {
               printf("FAIL [#%02u][INIT] ss hex parse/size mismatch\n", i);
               failures++;
               continue;
          }

          /* [VEC] decap(sk_vec, ct_vec) == ss_vec */
          printf("[#%02u][VEC] decapsulate(provided SK, provided CT) matches provided SS........", i);

          decap_ss_len = PQC_SMAUG1_SHAREDSECRET_SIZE;
          ret = axiocrypto_pqc_decapsulate(PQC_SMAUG1,
                                             sk, PQC_SMAUG1_SECRETKEY_SIZE,
                                             ct, PQC_SMAUG1_CIPHERTEXT_SIZE,
                                             decap_ss, &decap_ss_len);
          if (ret != PQC_SUCCESS) {
               printf("FAIL (decap ret=%d)\n", ret);
               failures++;
               continue;
          }
          if (decap_ss_len != PQC_SMAUG1_SHAREDSECRET_SIZE ||
               memcmp(decap_ss, ss, PQC_SMAUG1_SHAREDSECRET_SIZE) != 0) {
               printf("FAIL (ss mismatch)\n");
               failures++;
               continue;
          }
          printf("PASS\n");

          /* [RT] encap(pk_vec) -> decap(sk_vec) round-trip */
          printf("[#%02u][RT ] encapsulate(provided PK) then decapsulate(provided SK) matches...", i);

          encap_ct_len = PQC_SMAUG1_CIPHERTEXT_SIZE;
          ret = axiocrypto_pqc_encapsulate(PQC_SMAUG1,
                                             pk, PQC_SMAUG1_PUBLICKEY_SIZE,
                                             encap_ct, &encap_ct_len,
                                             ss_out, PQC_SMAUG1_SHAREDSECRET_SIZE);
          if (ret != PQC_SUCCESS) {
               printf("FAIL (encap ret=%d)\n", ret);
               failures++;
               continue;
          }
          if (encap_ct_len != PQC_SMAUG1_CIPHERTEXT_SIZE) {
               printf("FAIL (ctlen mismatch: got %u)\n", encap_ct_len);
               failures++;
               continue;
          }

          decap_ss_len = PQC_SMAUG1_SHAREDSECRET_SIZE;
          ret = axiocrypto_pqc_decapsulate(PQC_SMAUG1,
                                             sk, PQC_SMAUG1_SECRETKEY_SIZE,
                                             encap_ct, encap_ct_len,
                                             decap_ss, &decap_ss_len);
          if (ret != PQC_SUCCESS) {
               printf("FAIL (decap ret=%d)\n", ret);
               failures++;
               continue;
          }
          if (decap_ss_len != PQC_SMAUG1_SHAREDSECRET_SIZE ||
               memcmp(decap_ss, ss_out, PQC_SMAUG1_SHAREDSECRET_SIZE) != 0) {
               printf("FAIL (round-trip ss mismatch)\n");
               failures++;
               continue;
          }
          printf("PASS\n");
     }

     if (failures == 0) {
          printf("RESULT: SUCCESS (%u/%u passed)\n", n_pk, n_pk);
          ret = 0;
     } else {
          printf("RESULT: FAILED (%u/%u failed)\n", failures, n_pk);
          ret = -1;
     }
     printf("================================================================================\n\n");

cleanup:
     if (pk) free(pk);
     if (sk) free(sk);
     if (ct) free(ct);
     if (ss) free(ss);
     if (ss_out) free(ss_out);
     if (decap_ss) free(decap_ss);
     if (encap_ct) free(encap_ct);

     return ret;
}

void axiocrypto_pqc_smaug1_bench()
{
     int ret = 0;
     int i = 0;

     uint8_t sk[PQC_SMAUG1_SECRETKEY_SIZE] = {0x00,};
     size_t sklen = PQC_SMAUG1_SECRETKEY_SIZE;
     uint8_t pk[PQC_SMAUG1_PUBLICKEY_SIZE] = {0x00,};
     size_t pklen = PQC_SMAUG1_PUBLICKEY_SIZE;
     uint8_t ct[PQC_SMAUG1_CIPHERTEXT_SIZE] = {0x00,};
     size_t ctlen = PQC_SMAUG1_CIPHERTEXT_SIZE;
     uint8_t ss1[PQC_SMAUG1_SHAREDSECRET_SIZE] = {0x00,};
     size_t ss1len = PQC_SMAUG1_SHAREDSECRET_SIZE;
     uint8_t ss2[PQC_SMAUG1_SHAREDSECRET_SIZE] = {0x00,};
     size_t ss2len = PQC_SMAUG1_SHAREDSECRET_SIZE;

     TickType_t s, e;

     printf("(op=%d)\n", NTESTS);
     printf("============================================================\n");
     secure_stack_init();
     s = xTaskGetTickCount();
     for(i = 0; i < NTESTS; i++){
          ret = axiocrypto_pqc_keypair(PQC_SMAUG1, pk, pklen, sk, sklen);
          if(ret != PQC_SUCCESS){
               printf("SMAUG1 keypair generation failed(ret:%d)\n", ret);
               return;
          }
     }
     e = xTaskGetTickCount();
     printf("KeyGen:\t");
     print_elapsed_ms_ticks(s, e, NTESTS);
     printf(" | ");
     secure_stack_disp();

     secure_stack_init();
     s = xTaskGetTickCount();
     for(i = 0; i < NTESTS; i++){
          ctlen = PQC_SMAUG1_CIPHERTEXT_SIZE;
          ret = axiocrypto_pqc_encapsulate(PQC_SMAUG1, pk, pklen, ct, &ctlen, ss1, ss1len);
          if(ret != PQC_SUCCESS){
               printf("SMAUG1 encapsulation failed(ret:%d)\n", ret);
               return;
          }
     }
     e = xTaskGetTickCount();
     printf("Encap:\t");
     print_elapsed_ms_ticks(s, e, NTESTS);
     printf(" | ");
     secure_stack_disp();

     secure_stack_init();
     s = xTaskGetTickCount();
     for(i = 0; i < NTESTS; i++){
          ss2len = PQC_SMAUG1_SHAREDSECRET_SIZE;
          ret = axiocrypto_pqc_decapsulate(PQC_SMAUG1, sk, sklen, ct, ctlen, ss2, &ss2len);
          if(ret != PQC_SUCCESS){
               printf("SMAUG1 decapsulation failed(ret:%d)\n", ret);
               return;
          }
     }
     e = xTaskGetTickCount();
     printf("Decap:\t");
     print_elapsed_ms_ticks(s, e, NTESTS);
     printf(" | ");
     secure_stack_disp();
     printf("============================================================\n\n");

     return;
}
