#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#include "axiocrypto_pqc.h"
#include "axiocrypto_pqc_example.h"
#include "FreeRTOS.h"
#include "task.h"

static const char *hex_msg_vec[] = {
    "D81C4D8D734FCBFBEADE3D3F8A039FAA2A2C9957E835AD55B22E75BF57BB556AC8"
};
static const char *hex_pk_vec[] = {
    "91282214654CB55E7C2CACD53919604D62D94FED0FFB9282B6BE7963F9B1F0C0"
};
static const char *hex_sk_vec[] = {
    "7C9935A0B07694AA0C6D10E4DB6B1ADD91282214654CB55E7C2CACD53919604D62D94FED0FFB9282B6BE7963F9B1F0C0"
};
static const char *hex_sm_vec[] = {
    "D81C4D8D734FCBFBEADE3D3F8A039FAA2A2C9957E835AD55B22E75BF57BB556AC8B102A46FD378B5E6665BDAF78CEB04B0FB7894611CEFDA07E6C5D68593C5B65CE8B2054C931B2EE5A2A2BB48B311BD37A6B9A3BFA9AFD8E5A32DD4C8A30F309CFAF9EF08EC5EAA086B172E835195492AC1F3D02A9ED764B79E744400FFE15DA1551F7E5CFDC859B8760492FDFBF68B8D968B8DCEC0F4EF78899426674862D6DE6246315FC379DAB331D3E3C07DB7CD188BC8F20042153183D831C9928F4E7920264F35214C590BC019FBDB55382EC79A7A1107A933964B0880C5FC78022BBF6869748754113E7485FD9CAFDD64010D50CCDDAEC3A24807611018A7752F9253A3580151EBD0E656465589B4AEAED79EE8A2DA033C5239373F846C3D8678942B8948EB42BFF63EB03670E979FC6FEDD6C3299904D0CD2802CE0F747289FBDB542D0432F53147791F62CF2CFF4DCA3ECA027F4252726EB9B08DAD6002DB398FCD9A8A71F4B901564DD97EACBC6210A1FA6C0D5DC052C36A99547E4D8BD0A9999AD7F76AE01A3B03A610BD54A195EABB7686172ED851641BAF3D47C25BD23139396C47839680C4624139C0243D0063E4A1A63E60520316B399D79C7B3DE085A478325CFADF68647E983282A6670FB770A2D98E2FA82454A42B66025E2C46E57E89B8F9FC96D9A96A5295F190AE3B09A9422F4C7968BFFC4E63EA818C72C21406AB8C5C7347A3D093E661D9DE60E86659F951EB353535E96F907227BBA76361B5D7029B71A23EA7393508351D6439817A7926C790316849CB9EBC9BDF576D3F23366706DDBB6FE1CC0B160C0CA419101B7D7BF57787FEBDCF65586E606C6BA500497514F2FDAA6D6111B0B3780C95E249894D73F7421A9B02633230232230A09F8850662222240508C16AC599EB466D1E5491940493C574156A6DDF91B1ED3D410CC87BABA27439BBA7A6D8B2A69E32B259D0478FF6FF517CE704AB7B3C967337509EAC082E3DA2C76CCB68815F82D26B4E8D1EA8019FDF5648A8BB29870721627394D863B43F18BC61F95CAC0EE78CE99CA775A82E76BBA6D88608B3157A69F1C28CF5720EE226F5E316A55AD8FF0EB2EDE83D87EE4325F2555128A645CC883CA3836C3670AECD7D38FD28CEE017C60E919E2B8F3BCCAEE0A39CB156B395932CBD8D70F8C3B4E0A989CA8E53FA28BD49B3B4919AAA063D28B55BCA2A84E0BF6BD8FC1085FE9E8F8E4012F16CE57E8BCE54661738A7C48157C30F1584317161F2D3B807E1A219C0596233D027632542D3259E755B451896E58A7B4A940D9410BCB899754B430CA2B7AAA5064D7015CAC2EEC280F873AA65FD62F93BA55246F39A43EF80F52DD4AC773048D6017930937AA7806AE4C5FC7EE8A0706F905487EDC0B1E75CC1B9DAE33A7B49BEB38B50377C2AFE397A730045D1E1DAB74FE37F2B938875BAC9A9C6A75EC20CF4267AD0D89D0AA07D0E02DB72028CE3E0599D46C591B0701E7462389FC462443FC459E14114085B11B10E68B4EB149B1559BF7CC3928B8939A0DEDC2233C13BBC5EA35046B5F40CEC336FCCEDBADF36E6E2DE139F70837F989372B88D9F882D85E6AFF09986EB557705079AE91DD161D98D6E2999528B44C0E1B220794F0E9849BA34C92B8370ECC0122A9922937501DA56984D771F42BED3B3B29BF82ABB5E8EF971E1D6CDE06872FE5A5D26D5A0FF7A4F833C550BDA013ED92B86672E40C178DFCA7CE5B977207F289B6104864F80D82C6939DF7DDC04BD5115E360679C9BE6C13E81A58B42944309EEB0B66A90D69850526ED2ECA093CB0BC0B6F16CBE963EC3647438A6B3BDF9C7848608D6A1D99032415EA1BFFEE9DDCAD05DCA19352230C1645300259681F32EF98AEDBC3A3F6A16129F66891D221AE13BF608ECC285FDCD720C132465FF2DFC82B3BC35D5DDCC701F4DF661003616E405252AC1594C2F94F703BEF672045F9DC482AA8BBC692B4DB3B7FC7EC6E5DEB4194E8E0BC0E87E0561783C039B2D3F6CF7EAB69F3ADB225B2190D13F9855473D59BAF608641EDD9AFC7C7C1E88D34ABBAD8A790998769716ED9D7E3E89555EA533DAF8A62893E84B74C21A322523FBFC2F9462A6F7A3F4F3610E946140DD26D53594138D544EC0B3FF2DB025D105A6BE3C54CB2783E7C7D9084E3477D375D79BA4C4D24C058E57083ABD953C9CE6C560562C91EE5BCD5B2180EA484D4265E11EBC6FB2E818FAA46DECA60C5AF39CCC5D8578F0DF0A2DD93DE0C60D11A84FAE594C20F004832CC1A9C86B658D30C2D8FCBE52DB3221271F84E66D2B00BB1ADC8900E8B3682C79E92A86338EDA42B3F7F958FA0B446FDD7BDA834A1564CA07624712C5F61C252F0A7AFA3E910842A2DD0961FC0E252C801656DB9FA8DA3348F0DAD9BE5BE9D6F937D385849260C954EFD7EF287DBBB84988DA94DDAB1E7B8D1FD1DD49E4F9D0D9FAF9684812024AC5714CC6BAF79C45318ED6378F36F90DDAE6AA73DC29636B389A1C516A9536FAD6B87DCEF4EE44F5763B11C1E66DE4B319D337D491A945C0125CDAFB7CCFF0EA83707F3267D5FEDA333F322A8CBAB94301F906EA29B5CC5AC33BCB1EFB5D2915EF4459ED3452AAC0A2CA7DDA91981E0169D324AF87A64316A95E5D590745A8E7AE04FAFE921BF1A1FE343D2918E6A18D77A95E8CB7947D4D0C22A6B742FECA68806682EBCDC48C329910AD1181745CEA4E101FC6AB97FFF2586C2B07F877C7AE93DC7987344E03FF4A6669BB040E29DBDFC2557CE1BC4EC87BDD9FF81EE632812432E891A0112D7D026111451ED88D19D6310C673FEFC57C9E180C05E1089871FB55CFFA306EBF562C78100AF65D10F3F8AA5EF07E9860428FDC7FEF76EF2DC14C45B48F77E27C6CA25349132A0F19EAFDA595F2E604F922A94717FD4E3555A219A260634932FEFD77455D4C46B19266A78BB26249C7778F906592BAA579E0FECF09BDE539C5A32A2570E161F43C786AE4B18E26970EDDC6FA0D4CAE06CAF39E6C5E480FBF4DC051E28DD18CB8EEA064B29A8D994A023F5EC143BEC7C7E172EEB2A9BFAC6B47E41B96B4FC66F221EE2CB7E9996A85DB8C4C4F7E575D53C9AA3FC5AD29CB937A7572EC1A045EE3BD006041B0B78BD31E3FA41B9953E4341786DA3B535EABC6128A04312FD6776F2CC1A8093B7A262072E2CB0FFD605B72CACACD126D7B5AEE99C7A0A1F60FEBA2A21F414F2893875508EE6EAA792738CA3DCA6CE542C59A0074C814AB54F7D6CF8BA265E941AC07DB29657EEB0ADD9CE23A03019D17D36890F58A5ECDCB065C59BE06780AECF293ED5F09794D3788CFA828D82692CCDFF79B4FF7FBB5C470B492BFAE9F4CC9E09BEE933BA06B6C54A844AE4C093BA1F632C70CB0C9ABB83EF5DF883D372166DE084F94DF0D3A4C91D9030B3FC6709E656FDCFDEBBA8F6A82FA546FAD8DB96C8273074818142AEE07389FB0A8604AD95461BDC28E598CD9A953BC4F43D37945871746B294C14AA60800430A41A91B42FF3E43618822702C420D07A5C91D77704CD4055391560EE573C7D46818E0E77EFFA77E94C9A3290F7CC757DD5B1893D322A1FFCB29675F8883A59CF9F08E869027F77D8AB4F52828EC10AB26715135BF785A0FAA4EEB32197FE5E9B1CE36CE18D7D5F6DF3EE98BC108ADBCCC10E3701B703B858F7E7C99E91E7BF39AB246FA0BE51E91724DA8958CC2855D1D52A2779CBC520FF750C440CF134526DF9DDA1EBBD740186CD53BE2BCEDCAE48E483C0993E731C5262D7B31628C4659C754F2C9B6E4BD9E16F9B75F06541C2EFBFECE8D1AB5DADF6A5A05D6C02570FD6BB78F1B218951118E122BF3688296FE188F4787254EE8E7A7590E1B586853410931E1698D5F177EE2E7C028E64DD938E2B50AC2B7BED253C4C721F4B6763CD19B55C7F8DDC23BBDC8A7DA3EA0D036285F53BC8E3DFE5EE44D4F64C5E9BDFF04D874DDEC5F622201107E6177495AC3E9C47BC405D84F1B26FB581D59796C893F5016B488AFF4D782A2C7837A8161E5956FA4322EE41BC0C974256DD7B69DEE9B3EB0FEB9BFB0F8D4776844EC615412DA8A46D5DAAE0DCE96D54A475D5C0D4058CF6FF0D76A88FC04D21B5D4A438A9F69C638A8AB39A6B52A4E9C082585FF69BA24EAF39AA03A276D7A5AB490D827FBC24C83DE870DDC58A6C4CCCA98448CD3C3A723D63AD86E6927BF973B08065C6FC2002D7DED31E1792061248EB57259F77CBFA22AE3E45FE5CA70A1C0DCFD1959AD83135E0C8AE1A820F0F0DF11264BDD94ED79EBF2D91C5866F6FF44AC252CF75E8080B59D2A480141086E9A63FDF90A31396EB19C1BBA7E125D5C07B38C875760D72C9974F67A9C175748974F5D44D2D230EDD27055908EA0B28A4AA6F6CC90F6058243B17474DAFD76B53E328CF52B1D78C1A3EF1E926F34FCE0BF079C055E21DEE343C333FF237D511D3BD8FE00AF34029A2C6A87829FB3A170A8B0AF85A1BC387ADB5F5494A814813E93F700BA60891EC83FC593AA339C07B7881504F6E60B382D859B8CF2C309524C75E8FE40140455E674B7F5008651C7F5AF5E500B31DAB8A6BC1101BDD5D3B7DFFCA94FE038567A5493925BE50339C1F79EA6E267C41F5235DAA76AE1027D0F210DFC2E424B0210D10E72424D311008F60E058F7BC1982EF887B222FBA9ABE811BAEB30CA2C4D375C72D5EABF490A085AE16B6F56CC66D051547DA518A0BF4EEEE455DE794DD190478A1DD7451FAC9FC78D8A365FBE3B6D44F560D4BF7E0DCB4CA08FFD801E43DEE7BDE66DEF0D6A4E043F1C17429DD776D6B0A0D794C7AB1A7CBC33D5C4E5B2716CB9A74D86C4BA21EEA89B2FFE75DDB181E434C63A15B58482D37EC766AA07A33287CA7BB90C5E0B7C658D2D47057ED1C6B0480AB975B074C3200BBDDAD79A5C2C219CBAC749B25BC11DF02143363715CC0FAE004BE7C2998F3EA0BFF896D556E40292006F70C6E4B890B46E831F15BEAE2BB9087EC2796ABFF6A304A81DB2BEC8592797E568D32C681BE34EB8DCDD72B8E80F747D036261DF02B7A73F7F7BABBAA0F3D6D081C9FF2B41D3BE41C17FC7B7FC2CD8376AB80D6572BA3309D2FE91BECEA621408EB7BF3857E7EF1E6023BE616B0C255A1272C8CB9B897DDF9349554BA64F323343C2F1BB9C502777D22DA9A0D949FF5F23533A9F59493547321E4347FCF07BE1701F3DA0217615E52B4524CF2809FFC3DC332B683C285D269F66D5FABAD811E172D85C734C186DBF9A107EFBB7579B89B7075A302ADB48873E16F5D3FBCDDEFC45FEA6D4C3FB01C0C4E878C5DD2B56DE42C071CED73401290D2BBF0EDEDF0A00E5CFD2B2B8FE7B4C7D8414A15FDB47D4BD9AE52332618E543D9BE9669582B3482E575E4BC0A19AF21945E230C7CBE35B957D416AEE29419A942EDA6FF41EB3B18C7DC0DE3548BEC17EE124D025BA0AC3E210EB52D90467A6F6A0A215220304D9A0C49174420BC6EE9591FDDEF085B60CEF4CC32A4A920007976322D6D9F07D3AB06F670F0BFD2B7D05D76DD476D392D0B6F6E6087249F4061232066842EFFC56B6DA80233851BEC28FAF6156BA90CD9B7136583C218A6B283007A04E2D4C30EC502C6293FA67FC7E685A6AAD3939B875C08FCE370ED5B29CF47BB10D77A2C4E4637D2EC58A6D3041BCA2BCF2F5C0FE88B4632250ADAA82E9CD05DCF0E9DCECDD35D3BF929E55AE1091211C16AF37F1802983035F9B52E851D24821EB8DC3CD011E06856CFA935E4F0F234421938D285B59A478FAAD5E8E5040630B89F8E229C287E4EA01F6208D63FE13A92561DB81D802CDC16A9757909C0699782FE8D441E0BAA54BD1FC2D6CF297300E090345C1D471D677DA0C3AF1E0F0FBCBAD62B2DC90853D1072BE234505BA47F3C606AD3E76448F462AF3C54A0A40BEE2D3E28418685550E548C122C23DC479EF86F9C965997FAB8CB78E4022676548CEF1EE559069739C7763929198CF9ECC423AA0109CF90EADEEDFA6DFAE72300DE62BA0D14061286118C2BBE578F63BC7BF4B5AD34C5A0B1BF44878B09002F5D0B3CFF2D19FCDF5E7824A07233D8A711C284348DAB4B59DADA03592ABAEC1E261C395C40C3CE68CD5CFEB5B0D9ECDD61540872A6F64C8AF0D09F6ACA270F68D6DBC313BB22B8FD423783E1B9A9D3FEDA2A53D9A6083BBFC20355312A48B3E3FC25181A27CC09BBD60AA5B8B4824FCB2E6DF2C67DF1097CABE7150978ACE0C8A59F37A9AF69ABB07A87596D6F97B9DC107BE5C00D012414D8FABDA757E557204AB4ADA968B159ED9988D0748534ECD11151F35A238DF7B1BA274AE8CE9365CC3204CD4DCD01DA5DEC7D64692D16962065383DB5B22B5BFA5F8A3900A5D96E6DAC2E20AF9502018F6D332773B0F8AAC82CD6F408D59690DFDC5E59BE8C33B5DCCC1F987C6CF832A24F9FC0D79131A1D2E7D7F113B5107E289578A232FE2FFCE65C82D3AF3324D79690ECAB28F77F443D4C6FA563DFE03C5D200FF8E53B42772100F9D1756A7BF6D9CBFCA198FEA3F1B7E05A70C20B6826A6B98A9DBBC0A1A968624A1E87EEDC38BA4AC2F358B3478A85232F211CA527ECC4411315A952AECA1CC4BC3E589B7B8A325BB52E8A407AD02A0A9A154053DD9BC8F4FD982874F3759CD450125BFC4A2524277276853D068729804C2491B0AB9A7BC3CE0AD245C3FDA0E1F0D3032FFB9900E73E1FCCD1F6448117CF77904820CB45C9F976E86B27157895A254336F1F03B782A828DAAC0B639D3FFABEDF06CFE97A74FCB347AEC30FCD198CE95881241B6576B042B84C6E0344A28781BF5CEC22EDB810898146DBA2B69C510A719EC80FF760A34FA63276799D0C153F374743E683B186DBE01AD9ABEA0E867423C3A3B3370EEBC46B9077830AA8D6A2B29EC0952FDC0E9BD47D833C4EE3B5F011A77D7B538E71A18994C117886FED4550BDFBFDF2E47214399C9A671F4116E62BD5BDE6EEC3F1B8F1564BBBA64C6CCDD9F64C91E78320A788E31579D3B931FD37FA4057C23881B6B66D681E21F44E9C27464E01A5D0E62BC9DE09E7571CFD2C0682025A77BE0EB041F57732693CCD2E75AEE9A4B9D1E8419FAE7CD771F3EC967957E176421F69A93AF36F9E3C9700451C88E619A0F8212B9676B54590194E1696BDF13055356429D0E7B9233D1E553F226049C2355AE5A7ADB6098DCEBA7173C1E3B7B6EC03E0CEC78C96314FEB4F56F45D383BCE6EC9C1811B9EF08AA3088B7BBB9E7BB5AEBCFB100F491D77A237792ED496E67EB6116D5346272DAEE567451865F3BD42288F22C9D4458748AF2DF2C6C39BED0A4621D001F8C1FF45051C94DC22E256F9BDD7A8C2167383BF89A0C51BA844FE7837AFE3CA8BF78C686947FA99B0ACD4ABA5300262B03DA9BCD827B32FE60976024F7FEED5636E707D7889234B3EBF87325F351A7879B5FDB99178E21660B56FCF30A40DC4E4F4F897FC1DF635B79BC0364A642F3DA0E6A65C591184B91D0A5B34011DAD4C73D667A114C62CEC13A3841D02F4F68FC540799EFA52236015C0957C8207396A40FB01ADABD896706763076D770AD9417ADC4C29DA94DDD3B24BF4B0144C383EBF9AE07513A5E2E1FC3A727F0F86A0DF894005E1CC04F95D771EEB3CBD63903819D7721FA0F65C0DE615E6258465F8E7EA1B22939EECECC3ED937D6B85C954847E48E59E53364986141C1E26E3203A625071A151C68EBD1B7BB9E9D99947C8DFF629166026E7DCFFF0E9A84051561D5DF46626385373B2EBA0FCE8C1B244895D3CC5DEE567368E4DC89B3D8EFC6CE884F723F5CBC390752AF5B1AE2C591A2EC831617DD3A913DDCA672524E5E2442154FF8F32D2F2B8D9F89D5E66761FC0EB3576B03A47B457EDAA744144E93116EB5A979873790EEF5A74CA075FFF5590172B6A7E69D1CCEC75F7592A06558D724CED8CC0C8CC65B6F77F381B6BC8F499262AA92E3F66B0FF6E27D75E4A79E23BADE267309DBCB255D5BB25E2FE58726F050E98F53F9F286350DCC872AE71AEDD414A3962C041D11D654D8C9073919F0F21CD30F912BEC4F0167DA3A21C00B416F19C4FC0E0FF7155C4FCA58917BEDAAE216D8E9FAF42B683DA9C5285CD0973778509D2BEA956255D91A37EFE326DABE215F8F97C58237BE69BA92FE0DA312B75AB0EB32766CE00170B2E724AE46A15B1F52742380C542F1B26D9AF8ED18A859DD298ADCE44B039BA0BD8957E73FEEC69969CCE98D0FB8E7EAFB84A55593D5BFFCFE7B33428C7548BFC536897AB73FC33AED77065461858BE626665EC8A168924FF3BC6BCBBB8F3CCB1246B7AA3337F82A870F42AFF857683F5657818A1EAB4C67157C34D332DF24FA15EAAF65A1B7A3A4ADC8B6325238AF2C5CDEB38D6D4A4C78D2330DD9F2600BEA083D5F"
};

int axiocrypto_pqc_aimer128f_kat(void)
{
    int ret = -1;
    size_t i;
    size_t failures = 0;

    const size_t n_pk  = ARRAY_LEN(hex_pk_vec);
    const size_t n_sk  = ARRAY_LEN(hex_sk_vec);
    const size_t n_msg = ARRAY_LEN(hex_msg_vec);
    const size_t n_sm  = ARRAY_LEN(hex_sm_vec);

    uint8_t *pk = NULL, *sk = NULL, *msg = NULL, *sm = NULL;
    uint8_t *out_signed = NULL, *recovered = NULL;

    size_t msg_len = 0;
    size_t sm_len = 0;
    size_t recovered_len = 0;
    size_t out_signed_len = 0;

    const size_t out_signed_buf_len = (size_t)PQC_MSG_MAX_SIZE
                                    + (size_t)PQC_AIMER128F_SIGNATURE_SIZE
                                    + 1024;

    printf("================================================================================\n");

    /* 배열 정합성 체크 */
    if (n_pk == 0 || n_pk != n_sk || n_pk != n_msg || n_pk != n_sm) {
        printf("FAIL [INIT] vector count mismatch: pk=%u sk=%u msg=%u sm=%u\n",
               (unsigned)n_pk, (unsigned)n_sk, (unsigned)n_msg, (unsigned)n_sm);
        return -1;
    }

    pk = (uint8_t*)malloc(PQC_AIMER128F_PUBLICKEY_SIZE);
    if (!pk) { printf("FAIL [INIT] pk malloc failed\n"); goto cleanup; }

    sk = (uint8_t*)malloc(PQC_AIMER128F_SECRETKEY_SIZE);
    if (!sk) { printf("FAIL [INIT] sk malloc failed\n"); goto cleanup; }

    msg = (uint8_t*)malloc(PQC_MSG_MAX_SIZE);
    if (!msg) { printf("FAIL [INIT] msg malloc failed\n"); goto cleanup; }

    sm = (uint8_t*)malloc(out_signed_buf_len);
    if (!sm) { printf("FAIL [INIT] sm malloc failed\n"); goto cleanup; }

    out_signed = (uint8_t*)malloc(out_signed_buf_len);
    if (!out_signed) { printf("FAIL [INIT] out_signed malloc failed\n"); goto cleanup; }

    recovered = (uint8_t*)malloc(PQC_MSG_MAX_SIZE);
    if (!recovered) { printf("FAIL [INIT] recovered malloc failed\n"); goto cleanup; }

    for (i = 0; i < n_pk; i++) {
        /* 출력 버퍼 초기화 */
        memset(pk, 0, PQC_AIMER128F_PUBLICKEY_SIZE);
        memset(sk, 0, PQC_AIMER128F_SECRETKEY_SIZE);
        memset(msg, 0, PQC_MSG_MAX_SIZE);
        memset(sm, 0, out_signed_buf_len);
        memset(out_signed, 0, out_signed_buf_len);
        memset(recovered, 0, PQC_MSG_MAX_SIZE);

        msg_len = 0;
        sm_len = 0;

        /* 벡터 파싱 */
        if (hexTobin(hex_pk_vec[i], pk, PQC_AIMER128F_PUBLICKEY_SIZE) != (int)PQC_AIMER128F_PUBLICKEY_SIZE) {
            printf("FAIL [#%02u][INIT] pk hex parse/size mismatch\n", (unsigned)i);
            failures++;
            continue;
        }

        if (hexTobin(hex_sk_vec[i], sk, PQC_AIMER128F_SECRETKEY_SIZE) != (int)PQC_AIMER128F_SECRETKEY_SIZE) {
            printf("FAIL [#%02u][INIT] sk hex parse/size mismatch\n", (unsigned)i);
            failures++;
            continue;
        }

        msg_len = strlen(hex_msg_vec[i]) / 2;
        if (msg_len > PQC_MSG_MAX_SIZE) {
            printf("FAIL [#%02u][INIT] msg too large: %u bytes (max %u)\n",
                   (unsigned)i, (unsigned)msg_len, (unsigned)PQC_MSG_MAX_SIZE);
            failures++;
            continue;
        }
        if (hexTobin(hex_msg_vec[i], msg, msg_len) != (int)msg_len) {
            printf("FAIL [#%02u][INIT] msg hex parse/size mismatch\n", (unsigned)i);
            failures++;
            continue;
        }

        sm_len = strlen(hex_sm_vec[i]) / 2;
        if (sm_len > out_signed_buf_len) {
            printf("FAIL [#%02u][INIT] sm too large: %u bytes (buf %u)\n",
                   (unsigned)i, (unsigned)sm_len, (unsigned)out_signed_buf_len);
            failures++;
            continue;
        }
        if (hexTobin(hex_sm_vec[i], sm, sm_len) != (int)sm_len) {
            printf("FAIL [#%02u][INIT] sm hex parse/size mismatch\n", (unsigned)i);
            failures++;
            continue;
        }

        /* ---- [VEC] open(pk_vec, sm_vec) => recovered == msg_vec ---- */
        printf("[#%02u][VEC] open(provided PK, provided SM) matches provided MSG..............", (unsigned)i);

        recovered_len = PQC_MSG_MAX_SIZE;
        ret = axiocrypto_pqc_open(PQC_AIMER128F,
                                  pk, PQC_AIMER128F_PUBLICKEY_SIZE,
                                  sm, sm_len,
                                  recovered, &recovered_len);
        if (ret != PQC_SUCCESS) {
            printf("FAIL (open ret=%d)\n", ret);
            failures++;
            continue;
        }
        if (recovered_len != msg_len || memcmp(recovered, msg, msg_len) != 0) {
            printf("FAIL (recovered message mismatch)\n");
            failures++;
            continue;
        }
        printf("PASS\n");

        /* ---- [RT] sign(sk_vec, msg_vec) -> open(pk_vec, out_signed) ---- */
        printf("[#%02u][RT ] sign(provided SK, provided MSG) then open(provided PK) matches...", (unsigned)i);

        out_signed_len = out_signed_buf_len;
        ret = axiocrypto_pqc_sign(PQC_AIMER128F,
                                  sk, PQC_AIMER128F_SECRETKEY_SIZE,
                                  msg, msg_len,
                                  out_signed, &out_signed_len);
        if (ret != PQC_SUCCESS) {
            printf("FAIL (sign ret=%d)\n", ret);
            failures++;
            continue;
        }

        recovered_len = PQC_MSG_MAX_SIZE;
        ret = axiocrypto_pqc_open(PQC_AIMER128F,
                                  pk, PQC_AIMER128F_PUBLICKEY_SIZE,
                                  out_signed, out_signed_len,
                                  recovered, &recovered_len);
        if (ret != PQC_SUCCESS) {
            printf("FAIL (open ret=%d)\n", ret);
            failures++;
            continue;
        }
        if (recovered_len != msg_len || memcmp(recovered, msg, msg_len) != 0) {
            printf("FAIL (round-trip recovered message mismatch)\n");
            failures++;
            continue;
        }
        printf("PASS\n");
    }

    if (failures == 0) {
        printf("RESULT: SUCCESS (%u/%u passed)\n", (unsigned)n_pk, (unsigned)n_pk);
        ret = 0;
    } else {
        printf("RESULT: FAILED (%u/%u failed)\n", (unsigned)failures, (unsigned)n_pk);
        ret = -1;
    }
    printf("================================================================================\n\n");

cleanup:
    if (pk) free(pk);
    if (sk) free(sk);
    if (msg) free(msg);
    if (sm) free(sm);
    if (out_signed) free(out_signed);
    if (recovered) free(recovered);

    return ret;
}

void axiocrypto_pqc_aimer128f_bench()
{
    int ret = 0;

    uint8_t pk[PQC_AIMER128F_PUBLICKEY_SIZE] = {0x00,};
    uint8_t sk[PQC_AIMER128F_SECRETKEY_SIZE] = {0x00,};
    uint8_t sig[PQC_AIMER128F_SIGNATURE_SIZE] = {0x00,};
    size_t siglen = PQC_AIMER128F_SIGNATURE_SIZE;
    uint8_t msg[PQC_MSG_MAX_SIZE] = {0x00,};
    size_t msglen = PQC_MSG_MAX_SIZE;

    TickType_t s, e;

    printf("(op=%d, msglen=%d)\n", NTESTS, (int)msglen);
    printf("============================================================\n");
    secure_stack_init();
    s = xTaskGetTickCount();
    for(int i = 0; i < NTESTS; i++){
        ret = axiocrypto_pqc_keypair(PQC_AIMER128F, pk, PQC_AIMER128F_PUBLICKEY_SIZE, sk, PQC_AIMER128F_SECRETKEY_SIZE);
        if(ret != PQC_SUCCESS){
            printf("AIMER128F keypair generation failed(ret:%d)\n", ret);
            return;
        }
    }
    e = xTaskGetTickCount();
    printf("KeyGen:\t");
    print_elapsed_ms_ticks(s, e, NTESTS);
    printf(" | ");
    secure_stack_disp();

    secure_stack_init();
    s = xTaskGetTickCount();
    for(int i = 0; i < NTESTS; i++){
        ret = axiocrypto_pqc_sign_signature(PQC_AIMER128F, sk, PQC_AIMER128F_SECRETKEY_SIZE, msg, msglen, sig, &siglen);
        if(ret != PQC_SUCCESS){
            printf("AIMER128F signing failed(ret:%d)\n", ret);
            return;
        }
    }
    e = xTaskGetTickCount();
    printf("Sign:\t");
    print_elapsed_ms_ticks(s, e, NTESTS);
    printf(" | ");
    secure_stack_disp();
    
    secure_stack_init();
    s = xTaskGetTickCount();
    for(int i = 0; i < NTESTS; i++){
        ret = axiocrypto_pqc_verify(PQC_AIMER128F, pk, PQC_AIMER128F_PUBLICKEY_SIZE, msg, msglen, sig, siglen);
        if(ret != PQC_SUCCESS){
            printf("AIMER128F signature verification failed(ret:%d)\n", ret);
            return;
        }
    }
    e = xTaskGetTickCount();
    printf("Verify:\t");
    print_elapsed_ms_ticks(s, e, NTESTS);
    printf(" | ");
    secure_stack_disp();
    printf("============================================================\n\n");

    return;
}
