#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#include "axiocrypto_pqc.h"
#include "axiocrypto_pqc_example.h"
#include "FreeRTOS.h"
#include "task.h"

/* Provided hex vectors for Kyber512 */
static const char *hex_pk_vec[] = {
     "115ACE0E64677CBB7DCFC93C16D3A305F67615A488D711AA56698C5663AB7AC9CE66D547C0595F98A43F4650BBE08C364D976789117D34F6AE51AC063CB55C6CA32558227DFEF807D19C30DE414424097F6AA236A1053B4A07A76BE372A5C6B6002791EBE0AFDAF54E1CA237FF545BA68343E745C04AD1639DBC590346B6B9569B56DBBFE53151913066E5C85527DC9468110A136A411497C227DCB8C9B25570B7A0E42AADA6709F23208F5D496EBAB7843F6483BF0C0C73A40296EC2C6440001394C99CA173D5C775B7F415D02A5A26A07407918587C41169F2B7178755ACC27FC8B19C4C4B3FCD41053F2C74C8A10A8321241B2802432875AE808B9EF1365C7B8A52902F1317BA2FB0269F47930672107B4726FEF64547394D3320C8F120B3C2F4725B0305FAB88CC7981FCB09A76A1CBF7F179F43BB0A4C8B0590857F1E69708466C7F8607391E7BC5268BFD3D7A1DFFCB4ECA2A1C9B597593013D5FC4202EC2B74E57AB76BBCF3632BBAF97CDC418A6F16392838CA9BF45DDF023777B7561833C105190F94F302C59B531900BBC816361FAA5B3380CA3A893104CA7388B185671B3E5FE3790E9A626EC46D9B0B33C7A419AF7B32B6859894F575D82AC5456B5490A7AF8FE61046360589ECBA7244236F4123116B6174AA179249A49195B356C72FC6641F0251812EAA98570B046699070E0819DC2713F469137DFC6A3D7B92B298995EE780369153AC366B06D7249CD09E1B3378FB04399CECB8650581D637C79AE67D6F2CAF6ABACF598159A7792CB3C971D1499D2373AD20F63F03BB59ED137384AC61A7155143B8CA4932612EC915E4CA346A9BCE5DD60417C6B2A89B1CC435643F875BDC5A7E5B3481CF919EA09172FEBC46D4FC3FB0CB9591704EE2DBB61844B2F3314A06BB6C6D34005E485CE667BDC7D098586928D2D91340F00419EA401351A240A0B041058BEFB0C2FD32645B7A2DF8F5CBFD873327C978D7B351A28088438837024C52B9C295CD713646FB5D6C0CCFB470734AC2B2BC8123C2C13DF6938E92455A862639FEB8A64B85163E32707E037B38D8AC3922B45187BB65EAFD465FC64A0C5F8F3F9003489415899D59A543D8208C54A3166529B53922",
     "2C421AD4A7848CDC4B73987CF2F85E660C65E468346672AB09EA8B106B2ED51246271BC9D21672F6AA0B3A9B24C8F64722842F2E24CB2A47AAC689A5C57318663BC98756C199160F3A39C2148C574C23836DD060D1AC8A06794EDD5AA068AC19E42CCAAB951051756350C31D584A517FC9BB303276215580FDA99551E82449D8675F29C45AB6354107CC94509EE55AA5DB3A813ADB8B04005200ABA8F91B58A2D3B2B7D82C6461363353038099B7A0E981A85C75E0E422C572C506071DF54BB7B715B9F4A42DA1E89694A06475545D97A09EA36374F2C8BA40A5CC17EB1AD308AE862A26E38B2FFC11B7ABE3B58509B21649B86AAB9E0D1ABB601604C4152257A6691A964657BA0D1F561402545B782960E547A4DAB7B71AA95C67E64CAF568C3B3144FB29022CB0BF01B895E3327D019B591CA282D22105DA99B58BE42BAE7185E0B56CBD0C56EAD56B5DD34E9BC1859B927ED78C4EE1340960256A0B63CF4E1CC9E84A53A48B2F70C3C89E83A0005D65019A8419B5166469999A453418CB94295462D9256CCDDB3FCF8365CF0235F1D547498714A8B09553182FBA093F447A220146182A3ACF062A118B22CA49756505978F21DB629799CAD72AC5D17B2BFA52A6EA15672537899A313A4F0B7DF3F8639906BD0163735DEC5923A038FB7B5856570E279275C3093998338CB595C9A6B712C06C526166A725B9098EA02EA10C5D7CBB86B935703F122DEDB05233202968B59825F41F2C17BA76AC661FA69A7998C5FC6C2FB68A7820576B1FDA2C73DAA29CC21DCDCA47ADAA1B3B5258C1575FC9270712F3B8842978BE50A18DA45159B99272162891CB8A63CACFBC30BAE0A4364C8A6537E1B40E825C4A311488B133956690E494443AB44793D3717582701FAC5486DA4FFAF02C058BA688FB88DEB3C94E7445CFA89A79CA5F4B991ABCE25CD6B74AFBE9C63DFA0F40180B242AB52C1A455C0664F7357C048B27E05CA46B8605E6843C66FBC2A6A29BE135C39565A916ACADBBF2AA2656125B603BC88C9D710399A84850840169BE61BD4EF3687777075F0C7870B61903A26E6391A88B114E96F13F56BE785D942D7EAB011805CF3504FCE325B6A5EF1AAADBBB11C662B9D2"
};

static const char *hex_sk_vec[] = {
     "6C892B0297A9C7641493F87DAF3533EED61F07F4652066337ED74046DCC71BA03F30960103161F7DEB53A71B11617263FE2A809769CE6D70A85FE600ECE29D7F36A16D331B8B2A9E1DB8C090742DF0739FF060CEB4ECC5AB1C5E55AC97BB66A7F895105D57782B229538E3421544A3421408DBF44910934CC423774F1676FF1C306F97555F57B4AED7A6BAB950A8163C8D318DEA62751BD6ABC5069C06C88F330026A19806A03B97A7696B56DA21827BB4E8DC031152B41B892A9E99ADF6E1963E96578828154F467033846920FBB4B80544E7E8A81AE963CF368C9BA037A8C2AD62E32B6E61C91D75CE005AB30F8099A1F29D7B6305B4DC06E25680BB00992F717FE6C115A8084231CC79DD700EA6912AC7FA0D937BB6A756662230470C189B5AA1653DEB937D5A9C25A21D93B19074FC239D8153539797C7D4AB62649D76AA553736A949022C22C52BAEEC605B32CE9E5B9384903558CA9D6A3ABA90423EEDA01C94198B192A8BA9063497A0C5013307DDD863526471A4D99523EB417F291AAC0C3A581B6DA00732E5E81B1F7C879B1693C13B6F9F7931622429E542AF4069222F045544E0CC4FB24D4448CF2C6596F5CB08624B1185013B6B020892F96BDFD4ADA9179DE727B8D9426E0996B5D34948CE02D0C369B37CBB54D3479ED8B582E9E728929B4C71C9BE11D45B20C4BDC3C74313223F58274E8BA5244447C495950B84CB0C3C273640108A3397944573279328996CDC0C913C958AD620BA8B5E5ECBBB7E13CB9C70BD5AB30EB7488C97001C20498F1D7CC06DA76BF520C658CCADFA2956424557ABEA8AB89239C17833DC3A49B36A9AE9A486940540EB444F97152357E02035939D75A3C025F41A40082382A0733C39B0622B740E407592C62ECAEB1432C445B3703A86F6981A278157EA95A6E92D55E4B972F936C2F0A658280EA2B07A48992DF8937E0A2AC1DCC974FE00AAE1F561FA258E2D259C3E861DCE236039127606FC1CE009003A7BAC942101DCB822B1F3C12BF73238F546E01C36B5A6936192995CC69C63237409CB53C2E35D74890D18885376FA5503B107A2A392115ACE0E64677CBB7DCFC93C16D3A305F67615A488D711AA56698C5663AB7AC9CE66D547C0595F98A43F4650BBE08C364D976789117D34F6AE51AC063CB55C6CA32558227DFEF807D19C30DE414424097F6AA236A1053B4A07A76BE372A5C6B6002791EBE0AFDAF54E1CA237FF545BA68343E745C04AD1639DBC590346B6B9569B56DBBFE53151913066E5C85527DC9468110A136A411497C227DCB8C9B25570B7A0E42AADA6709F23208F5D496EBAB7843F6483BF0C0C73A40296EC2C6440001394C99CA173D5C775B7F415D02A5A26A07407918587C41169F2B7178755ACC27FC8B19C4C4B3FCD41053F2C74C8A10A8321241B2802432875AE808B9EF1365C7B8A52902F1317BA2FB0269F47930672107B4726FEF64547394D3320C8F120B3C2F4725B0305FAB88CC7981FCB09A76A1CBF7F179F43BB0A4C8B0590857F1E69708466C7F8607391E7BC5268BFD3D7A1DFFCB4ECA2A1C9B597593013D5FC4202EC2B74E57AB76BBCF3632BBAF97CDC418A6F16392838CA9BF45DDF023777B7561833C105190F94F302C59B531900BBC816361FAA5B3380CA3A893104CA7388B185671B3E5FE3790E9A626EC46D9B0B33C7A419AF7B32B6859894F575D82AC5456B5490A7AF8FE61046360589ECBA7244236F4123116B6174AA179249A49195B356C72FC6641F0251812EAA98570B046699070E0819DC2713F469137DFC6A3D7B92B298995EE780369153AC366B06D7249CD09E1B3378FB04399CECB8650581D637C79AE67D6F2CAF6ABACF598159A7792CB3C971D1499D2373AD20F63F03BB59ED137384AC61A7155143B8CA4932612EC915E4CA346A9BCE5DD60417C6B2A89B1CC435643F875BDC5A7E5B3481CF919EA09172FEBC46D4FC3FB0CB9591704EE2DBB61844B2F3314A06BB6C6D34005E485CE667BDC7D098586928D2D91340F00419EA401351A240A0B041058BEFB0C2FD32645B7A2DF8F5CBFD873327C978D7B351A28088438837024C52B9C295CD713646FB5D6C0CCFB470734AC2B2BC8123C2C13DF6938E92455A862639FEB8A64B85163E32707E037B38D8AC3922B45187BB65EAFD465FC64A0C5F8F3F9003489415899D59A543D8208C54A3166529B539227FFAD1BC8AF73B7E874956B81C2A2EF0BFABE8DC93D77B2FBC9E0C64EFA01E848626ED79D451140800E03B59B956F8210E556067407D13DC90FA9E8B872BFB8F",
     "E1785B13943F2661C372CA63A0C6AEDED27F46C81B837293B9867B9F7CCE0611C61B318ADFD67C09969C27A095E53C124B048CD99027C9103E85C5C4D72730A34C8ADC406ECEB4AFE02444671319DF175465EA9A0D91291C18CFC9367A333475727B64E6F73E50233B81AC0978364D18F72DB39A4041D4B25A095DF99BCBED090496DAB62AA250945A97BD297A539A1AF51648C8378C1B21A2FC311B57860C368A819F2B8C15477243256970313B2AE082C2F8BDACB658A89C6BDC788325D48292DC2395F51DF765A4A2E927769C84F5FC306568B4B5E7487B8B9F79DCCE33C80B988C955544CCA478AAC902C2A6F2A4BC9A9478A9B318F78586C696942B6F4C2931E85042DB27314CB546BEBC2236C2136D581EE22978D2B79EA3B662A8BC7CC17CCBDB59AEF8B0CD77A4A680672E9AB4ADC2D011BF471865F92F4A4769A8157B87769AC3B86448851E80F8BABF394907D4C8A51C7BA4CA62CD7AB7BBC4219778CE4DC22955772DBD1330C10055DBE106D11863D7B14B6301A622EC35F3AB9B3494C12E3929BC321950FA1036D98A3B257C20D378A9798BD3B57E50EC88617B49B75022E10130E35432F3ABC7165952E2B7652C0BB1FA92A16D7B3273D2709077164BC60CBBE747205B6DBBE5912947CA3914C1A106B66708212D443898616273E006ED507E30D7A7B6E389739B637609834561AD4E227DA0289ED9180BFAA48A58EA75CC1744F75007A99611EAE775A1F5411F1376A7F25E758C8B69BA731D28BF016970A9A3579ED7150C526B098C4AD277C6D7294462CA65B6F3B7062956551428477B9C57301ECADB9C7ADACA67C0423F42704B008A90861B45C19D24E521080C69FD20A5DCA45ACA18ABB356375A983081567E22798F530AA1E0AABC2D7B3A208446E9081BA2420B8AFCB8EDD37DB536689695749B632D99316653E97056260979974E44D135589A283DD1486856BD1AF59E24394743C7A036A68161E31010CAC462A6A7AC0058E1640AAA686311D939537171B8128965C70FE8EB0F10DC1A2BC50ABA436E2AF19FFBB3C6451A9FE7784678A519473010F9E69F9601502C421AD4A7848CDC4B73987CF2F85E660C65E468346672AB09EA8B106B2ED51246271BC9D21672F6AA0B3A9B24C8F64722842F2E24CB2A47AAC689A5C57318663BC98756C199160F3A39C2148C574C23836DD060D1AC8A06794EDD5AA068AC19E42CCAAB951051756350C31D584A517FC9BB303276215580FDA99551E82449D8675F29C45AB6354107CC94509EE55AA5DB3A813ADB8B04005200ABA8F91B58A2D3B2B7D82C6461363353038099B7A0E981A85C75E0E422C572C506071DF54BB7B715B9F4A42DA1E89694A06475545D97A09EA36374F2C8BA40A5CC17EB1AD308AE862A26E38B2FFC11B7ABE3B58509B21649B86AAB9E0D1ABB601604C4152257A6691A964657BA0D1F561402545B782960E547A4DAB7B71AA95C67E64CAF568C3B3144FB29022CB0BF01B895E3327D019B591CA282D22105DA99B58BE42BAE7185E0B56CBD0C56EAD56B5DD34E9BC1859B927ED78C4EE1340960256A0B63CF4E1CC9E84A53A48B2F70C3C89E83A0005D65019A8419B5166469999A453418CB94295462D9256CCDDB3FCF8365CF0235F1D547498714A8B09553182FBA093F447A220146182A3ACF062A118B22CA49756505978F21DB629799CAD72AC5D17B2BFA52A6EA15672537899A313A4F0B7DF3F8639906BD0163735DEC5923A038FB7B5856570E279275C3093998338CB595C9A6B712C06C526166A725B9098EA02EA10C5D7CBB86B935703F122DEDB05233202968B59825F41F2C17BA76AC661FA69A7998C5FC6C2FB68A7820576B1FDA2C73DAA29CC21DCDCA47ADAA1B3B5258C1575FC9270712F3B8842978BE50A18DA45159B99272162891CB8A63CACFBC30BAE0A4364C8A6537E1B40E825C4A311488B133956690E494443AB44793D3717582701FAC5486DA4FFAF02C058BA688FB88DEB3C94E7445CFA89A79CA5F4B991ABCE25CD6B74AFBE9C63DFA0F40180B242AB52C1A455C0664F7357C048B27E05CA46B8605E6843C66FBC2A6A29BE135C39565A916ACADBBF2AA2656125B603BC88C9D710399A84850840169BE61BD4EF3687777075F0C7870B61903A26E6391A88B114E96F13F56BE785D942D7EAB011805CF3504FCE325B6A5EF1AAADBBB11C662B9D213F0970C03D32967B06CCA4CF58E87559128D14CB3F876A1ED10EADFE03FC1A9003271531CF27285B8721ED5CB46853043B346A66CBA6CF765F1B0EAA40BF672"
};

static const char *hex_ct_vec[] = {
     "EDF24145E43B4F6DC6BF8332F54E02CAB02DBF3B5605DDC90A15C886AD3ED489462699E4ABED44350BC3757E2696FBFB2534412E8DD201F1E4540A3970B055FE3B0BEC3A71F9E115B3F9F39102065B1CCA8314DCC795E3C0E8FA98EE83CA6628457028A4D09E839E554862CF0B7BF56C5C0A829E8657947945FE9C22564FBAEBC1B3AF350D7955508A26D8A8EB547B8B1A2CF03CCA1AABCE6C3497783B6465BA0B6E7ACBA821195124AEF09E628382A1F914043BE7096E952CBC4FB4AFED13609046117C011FD741EE286C83771690F0AEB50DA0D71285A179B215C6036DEB780F4D16769F72DE16FDADAC73BEFA5BEF8943197F44C59589DC9F4973DE1450BA1D0C3290D6B1D683F294E759C954ABE8A7DA5B1054FD6D21329B8E73D3756AFDA0DCB1FC8B1582D1F90CF275A102ABC6AC699DF0C5870E50A1F989E4E6241B60AAA2ECF9E8E33E0FFCF40FE831E8FDC2E83B52CA7AB6D93F146D29DCA53C7DA1DB4AC4F2DB39EA120D90FA60F4D437C6D00EF483BC94A3175CDA163FC1C2828BE4DBD6430507B584BB5177E171B8DDA9A4293C3200295C803A865D6D2166F66BA5401FB7A0E853168600A2948437E036E3BF19E12FD3F2A2B8B343F784248E8D685EB0AFDE6315338730E7A1001C27D8D2A76FA69D157BA1AC7AD56DA5A8C70FE4B5B8D786DC6FC0566BA8E1B8816334D32A3FB1CE7D4D5E4C332AF7B003D091741A3D5C965292255DFF8ED2BBF1F9116BE50C17B8E548748AD4B2E957BBD1953482A2E1718CEC66CD2C81F572D552B7187885E6B8943D6431413C59EBB7E036048490BE5289E95B20A89E8B159F61A9A9886E147568F4C9021F362F02688A1C8C3BB0D24086880E55B6EDB43F3745D2C166DC1CB743C76FE6BE523A893CC764D16435C37851252A81E2FFBA0F18971A3DEE37D4877CB928E36E5235037A6B2057897D518A5F0E348E3AB6D5B52DFC60757F3B41A4FEC7828F1DEEAF4587CCC8EADF647F4D203B2FAA05A649B582340CB4CACE57A30711BE752FACF0227D0A80C4128442DDC544BE805B9CFE8FE9B1237C80F96787CD9281CCF270C1AFC0670D",
     "148869316FF02E3434078481B0EFD5C01697B0B6A95448E34D38F1BF326AB9B7215CDBB7A43FA2AF48760E4D595278538D482E067549F46D725114DCF6EFE5DC1FE7F8E6023F225FB3CFA8B17B1DC06B1D639A786DBD337793699BFED98C533203E8A053F210DE15887CCC5174CFAA7E6D99AD11E61A8D3DECBB5D2C9DE33F96DF78855B55D9CF62FF8597C5D61DE8E24BCF6C792CB57AC0B249FDD2D83A493716FA06FAA5E3AD4BEE1BE8EA00B789E5197E02902CB64A7A7B02416427A58E1EEDE1E23805908756ACD919DA013F8B53584F77A55BF5E8F28B9FB062279F0AEAF93B2C7B76D2FC70E94F680FB7884D4FF9CBDD28A948360B8D48DB38D617B98F5DCA38965A1F42FA9FDF154EF5883EB1A89D08CB5B861F783B8FA1FE99F1253C782D2035E667E7AFA6FC8D5EECC3137633A8F9429C1A50AFBF3302D30826C8EB57BE8C11C3A9DC70CF1D8449ACE55EDA070E3FE0FF71789A32A309242A8D740413576B659120A23ED0F1C35AD2CFB40CDDA23E3DFC5E7D18E8B22C74081B604725ECCF0541EB4F007919B7ECA52FC23AE229D9754337633425E4238E6F3EB0A265C90EDAD0C6A5885B3B1B58B549C6C4CEA5154E60AEF72A72C7D991198F5C855957896007EC0BEC440450E6F64092DA3F8E12B29A26AFF0A5EA08A36C01EE46074B5B3E9F00ABE821187D3DF337E4E18CF4BBF9A0D7D2DAADF0574AF638B71178743F907CF8168B73277342193B8BA4F0B55767456A778E071B73517A3BF9A1151D51B86F26CE7F1A0D6E0D2BC8FE60FE6ABF6F01439C5B0E09A93AC4A7B03E92B80B0C669F4561E8FD3DF47B4D61C79C000CEEEC451B607AA1F3DAB186A6ABA51F155C56A1357566AEAC90B8C198E45DB251FB3A1BB020F068F7027BF86E0B83327CC88DC1B963CD9BA5E8C7B68F22A27CCF87B55481D46A804121D819C9BDFA4E0C1FF5E4907DBA06DD4E2F95FEA50A22B60D0AD383E7630494407BF6728AB7AF746F4B115F1969C50222DD8006BF0DA01756FEE5AF6A400B884F9076310000F3BA694AAE5CFF0B4C7FD837F58286A25E10CA4735EFDB7EC0D7AACFA83D2C"
};

static const char *hex_ss_vec[] = {
     "0A6925676F24B22C286F4C81A4224CEC506C9B257D480E02E3B49F44CAA3237F",
     "CED6EC70083226B02057B7F47E40943320B3D10DD4AD07EFE0F007EC8C06B3AF"
};

int axiocrypto_pqc_kyber512_kat(void)
{
     int ret = -1;
     size_t i;
     size_t failures = 0;

     const size_t n_pk = ARRAY_LEN(hex_pk_vec);
     const size_t n_sk = ARRAY_LEN(hex_sk_vec);
     const size_t n_ct = ARRAY_LEN(hex_ct_vec);
     const size_t n_ss = ARRAY_LEN(hex_ss_vec);

     uint8_t *pk = NULL, *sk = NULL, *ct = NULL, *ss = NULL;
     uint8_t *ss_out = NULL, *decap_ss = NULL, *encap_ct = NULL;

     size_t encap_ct_len = 0;
     size_t decap_ss_len = 0;

     printf("================================================================================\n");
     /* 배열 정합성 체크 */
     if (n_pk == 0 || n_pk != n_sk || n_pk != n_ct || n_pk != n_ss) {
          printf("FAIL [INIT] vector count mismatch: pk=%u sk=%u ct=%u ss=%u\n",
                    n_pk, n_sk, n_ct, n_ss);
          return -1;
     }

     pk = (uint8_t*)malloc(PQC_KYBER512_PUBLICKEY_SIZE);
     if(pk == NULL) {
          printf("FAIL [INIT] pk malloc failed\n");
          ret = -1;
          goto cleanup;
     }
     sk = (uint8_t*)malloc(PQC_KYBER512_SECRETKEY_SIZE);
     if(sk == NULL) {
          printf("FAIL [INIT] sk malloc failed\n");
          ret = -1;
          goto cleanup;
     }
     ct = (uint8_t*)malloc(PQC_KYBER512_CIPHERTEXT_SIZE);
     if(ct == NULL) {
          printf("FAIL [INIT] ct malloc failed\n");
          ret = -1;
          goto cleanup;
     }
     ss = (uint8_t*)malloc(PQC_KYBER512_SHAREDSECRET_SIZE);
     if(ss == NULL) {
          printf("FAIL [INIT] ss malloc failed\n");
          ret = -1;
          goto cleanup;
     }
     ss_out  = (uint8_t*)malloc(PQC_KYBER512_SHAREDSECRET_SIZE);
     if(ss_out == NULL) {
          printf("FAIL [INIT] ss_out malloc failed\n");
          ret = -1;
          goto cleanup;
     }
     encap_ct= (uint8_t*)malloc(PQC_KYBER512_CIPHERTEXT_SIZE);
     if(encap_ct == NULL) {
          printf("FAIL [INIT] encap_ct malloc failed\n");
          ret = -1;
          goto cleanup;
     }
     decap_ss= (uint8_t*)malloc(PQC_KYBER512_SHAREDSECRET_SIZE);
     if(decap_ss == NULL) {
          printf("FAIL [INIT] decap_ss malloc failed\n");
          ret = -1;
          goto cleanup;
     }

     for (i = 0; i < n_pk; i++) {
          /* 출력버퍼 초기화 */
          memset(ss_out,   0, PQC_KYBER512_SHAREDSECRET_SIZE);
          memset(decap_ss, 0, PQC_KYBER512_SHAREDSECRET_SIZE);
          memset(encap_ct, 0, PQC_KYBER512_CIPHERTEXT_SIZE);

          /* 벡터 파싱 */
          if (hexTobin(hex_pk_vec[i], pk, PQC_KYBER512_PUBLICKEY_SIZE) != (int)PQC_KYBER512_PUBLICKEY_SIZE) {
               printf("FAIL [#%02u][INIT] pk hex parse/size mismatch\n", i);
               failures++;
               continue;
          }
          if (hexTobin(hex_sk_vec[i], sk, PQC_KYBER512_SECRETKEY_SIZE) != (int)PQC_KYBER512_SECRETKEY_SIZE) {
               printf("FAIL [#%02u][INIT] sk hex parse/size mismatch\n", i);
               failures++;
               continue;
          }
          if (hexTobin(hex_ct_vec[i], ct, PQC_KYBER512_CIPHERTEXT_SIZE) != (int)PQC_KYBER512_CIPHERTEXT_SIZE) {
               printf("FAIL [#%02u][INIT] ct hex parse/size mismatch\n", i);
               failures++;
               continue;
          }
          if (hexTobin(hex_ss_vec[i], ss, PQC_KYBER512_SHAREDSECRET_SIZE) != (int)PQC_KYBER512_SHAREDSECRET_SIZE) {
               printf("FAIL [#%02u][INIT] ss hex parse/size mismatch\n", i);
               failures++;
               continue;
          }

          /* [VEC] decap(sk_vec, ct_vec) == ss_vec */
          printf("[#%02u][VEC] decapsulate(provided SK, provided CT) matches provided SS........", i);

          decap_ss_len = PQC_KYBER512_SHAREDSECRET_SIZE;
          ret = axiocrypto_pqc_decapsulate(PQC_ML_KEM_512,
                                             sk, PQC_KYBER512_SECRETKEY_SIZE,
                                             ct, PQC_KYBER512_CIPHERTEXT_SIZE,
                                             decap_ss, &decap_ss_len);
          if (ret != PQC_SUCCESS) {
               printf("FAIL (decap ret=%d)\n", ret);
               failures++;
               continue;
          }
          if (decap_ss_len != PQC_KYBER512_SHAREDSECRET_SIZE ||
               memcmp(decap_ss, ss, PQC_KYBER512_SHAREDSECRET_SIZE) != 0) {
               printf("FAIL (ss mismatch)\n");
               failures++;
               continue;
          }
          printf("PASS\n");

          /* [RT] encap(pk_vec) -> decap(sk_vec) round-trip */
          printf("[#%02u][RT ] encapsulate(provided PK) then decapsulate(provided SK) matches...", i);

          encap_ct_len = PQC_KYBER512_CIPHERTEXT_SIZE;
          ret = axiocrypto_pqc_encapsulate(PQC_ML_KEM_512,
                                             pk, PQC_KYBER512_PUBLICKEY_SIZE,
                                             encap_ct, &encap_ct_len,
                                             ss_out, PQC_KYBER512_SHAREDSECRET_SIZE);
          if (ret != PQC_SUCCESS) {
               printf("FAIL (encap ret=%d)\n", ret);
               failures++;
               continue;
          }
          if (encap_ct_len != PQC_KYBER512_CIPHERTEXT_SIZE) {
               printf("FAIL (ctlen mismatch: got %u)\n", encap_ct_len);
               failures++;
               continue;
          }

          decap_ss_len = PQC_KYBER512_SHAREDSECRET_SIZE;
          ret = axiocrypto_pqc_decapsulate(PQC_ML_KEM_512,
                                             sk, PQC_KYBER512_SECRETKEY_SIZE,
                                             encap_ct, encap_ct_len,
                                             decap_ss, &decap_ss_len);
          if (ret != PQC_SUCCESS) {
               printf("FAIL (decap ret=%d)\n", ret);
               failures++;
               continue;
          }
          if (decap_ss_len != PQC_KYBER512_SHAREDSECRET_SIZE ||
               memcmp(decap_ss, ss_out, PQC_KYBER512_SHAREDSECRET_SIZE) != 0) {
               printf("FAIL (round-trip ss mismatch)\n");
               failures++;
               continue;
          }
          printf("PASS\n");
     }

     if (failures == 0) {
          printf("RESULT: SUCCESS (%u/%u passed)\n", n_pk, n_pk);
          ret = 0;
     } else {
          printf("RESULT: FAILED (%u/%u failed)\n", failures, n_pk);
          ret = -1;
     }
     printf("================================================================================\n\n");

cleanup:
     if (pk) free(pk);
     if (sk) free(sk);
     if (ct) free(ct);
     if (ss) free(ss);
     if (ss_out) free(ss_out);
     if (decap_ss) free(decap_ss);
     if (encap_ct) free(encap_ct);

     return ret;
}

void axiocrypto_pqc_kyber512_bench()
{
     int ret = 0;
     int i = 0;

     uint8_t sk[PQC_KYBER512_SECRETKEY_SIZE] = {0x00,};
     size_t sklen = PQC_KYBER512_SECRETKEY_SIZE;
     uint8_t pk[PQC_KYBER512_PUBLICKEY_SIZE] = {0x00,};
     size_t pklen = PQC_KYBER512_PUBLICKEY_SIZE;
     uint8_t ct[PQC_KYBER512_CIPHERTEXT_SIZE] = {0x00,};
     size_t ctlen = PQC_KYBER512_CIPHERTEXT_SIZE;
     uint8_t ss1[PQC_KYBER512_SHAREDSECRET_SIZE] = {0x00,};
     size_t ss1len = PQC_KYBER512_SHAREDSECRET_SIZE;
     uint8_t ss2[PQC_KYBER512_SHAREDSECRET_SIZE] = {0x00,};
     size_t ss2len = PQC_KYBER512_SHAREDSECRET_SIZE;

     TickType_t s, e;

     printf("(op=%d)\n", NTESTS);
     printf("============================================================\n");
     secure_stack_init();
     s = xTaskGetTickCount();
     for(i = 0; i < NTESTS; i++){
          ret = axiocrypto_pqc_keypair(PQC_ML_KEM_512, pk, pklen, sk, sklen);
          if(ret != PQC_SUCCESS){
               printf("KYBER512 keypair generation failed(ret:%d)\n", ret);
               return;
          }
     }
     e = xTaskGetTickCount();
     printf("KeyGen:\t");
     print_elapsed_ms_ticks(s, e, NTESTS);
     printf(" | ");
     secure_stack_disp();

     secure_stack_init();
     s  = xTaskGetTickCount();
     for(i = 0; i < NTESTS; i++){
          ctlen = PQC_KYBER512_CIPHERTEXT_SIZE;
          ret = axiocrypto_pqc_encapsulate(PQC_ML_KEM_512, pk, pklen, ct, &ctlen, ss1, ss1len);
          if(ret != PQC_SUCCESS){
               printf("KYBER512 encapsulation failed(ret:%d)\n", ret);
               return;
          }
     }
     e = xTaskGetTickCount();
     printf("Encap:\t");
     print_elapsed_ms_ticks(s, e, NTESTS);
     printf(" | ");
     secure_stack_disp();

     secure_stack_init();
     s = xTaskGetTickCount();
     for(i = 0; i < NTESTS; i++){
          ss2len = PQC_KYBER512_SHAREDSECRET_SIZE;
          ret = axiocrypto_pqc_decapsulate(PQC_ML_KEM_512, sk, sklen, ct, ctlen, ss2, &ss2len);
          if(ret != PQC_SUCCESS){
               printf("KYBER512 decapsulation failed(ret:%d)\n", ret);
               return;
          }
     }
     e = xTaskGetTickCount();
     printf("Decap:\t");
     print_elapsed_ms_ticks(s, e, NTESTS);
     printf(" | ");
     secure_stack_disp();
     printf("============================================================\n\n");

     return;
}
