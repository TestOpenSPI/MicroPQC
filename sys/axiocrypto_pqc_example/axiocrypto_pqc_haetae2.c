#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>

#include "axiocrypto_pqc.h"
#include "axiocrypto_pqc_example.h"
#include "FreeRTOS.h"
#include "task.h"

static const char *hex_msg_vec[] = {
    "D81C4D8D734FCBFBEADE3D3F8A039FAA2A2C9957E835AD55B22E75BF57BB556AC8"
};
static const char *hex_pk_vec[] = {
    "1C0EE1111B08003F28E65E8B3BDEB037CF8F221DFCDAF5950EDB38D506D85BEF85950665A0F462C9ADAD48717D19F456D8F0ADC18B028C4C39B3EAE5447DF262AC2C1FC949437CDA1579D3A081124801C39BDEA38B7D86259B81AD17E299D1C6A7CE6DE5C394BE0297E57A5436948A807E908F78A3950704440490BB63CFDCC84AA506E032AF54AD933E65EC98B507D8651E551E31242E6130781E4BE4101C29511E365D16E4DEA048B119EE94B9D4F4721093D72D3E98289804219121762F945BE0A6D196A3C55595C90433C623054309A7BB6329267CB78343AFEEDE3371A5406EBA7A8F3B199799112A5B84FEB8EECCBEA40BFC2D7DB3D1020D855493BE776AF212719054CABD4AA8F6E7ABEC104D3C82F86F16DD906FC7552510523C951A79D4F67A9833E96DD960D39764AE6E472CE54384454C072693DA4110BCBAB7A4B871D924328B31E53B55A58BF669BD0380F96BE52C56BC71C91D31CE02F9E72E5473192B28F052AB41BE4615F808C525D791BADF605CB5E467569AD00D6A8F5D81191A5A768E784A480F739B8948E0464975DE5015EF2844C83AA4A089826EDC9190DF6D7CD39046EE3A883CBA109C447EC97A901674C0AC72E1A7C04541D324928BF493810D844239D7B5E74D254587D19199676D3365B8CC501376A7CA843E713552585900ABC73B49A2EB2ED387A74CAE423E2648A6AABA8027A5180422EDA3A9E4B0D950626566F3578F0220AFAD787EB9B315CF03C862D5CF12E84D58A3A1704044570B209749F61B3ABD3AD692E3421FF86B2E6D2E29437EE283E9EE21C886576530B6E7FAD1AC04AAD6B67741CD90AFD75C18998CE1AFB9FB32C4B910CF61AB80D6F12C88CC463B40734868AC74BAE1793071EF9F98A646C832023BA3B0C3798909C17DDA5E969BFEDA01E492B94E581595E2BA3C298D159AC20DAAD4B44D7E79B51E6791802D4B12025DE3344247A083F8D9FF1CC7C146EFD81D6F72A13DDD08494914D10C0B5DA7372EEBBAD4EF4E61B008A188A125FB2C8729E06C473F5A04214C1FD8048870575192F1B4D6D1A129F83EF85AD230AEABFC2891286BC9FA92999C69C73733DA9C54836907DD1EAB962001F90826EC01AADB0A88736816F36F689B005442234DF407BD062479EAD72CD0711F916261708426C91B10AC05E36D02494D280D037A1F202CA4F0C32A168B593B0021BE4AAB739391735FF3C1A572B261243A527CB2157919B8421FD256DA59597B0E390B8D6E901EFE98863EB09FA32F7239348087BA399E892262E9ACCD86A209BC4B8F86E56EEDAB181DC70C9AD355551E284DB2EAFF537051D7B588741B1D3A3550CD0A352F30C91D147F723C3B392F52ECE773D0B6835B19403880CC5CE2CDF182029042FD57ADC3"
};
static const char *hex_sk_vec[] = {
    "1C0EE1111B08003F28E65E8B3BDEB037CF8F221DFCDAF5950EDB38D506D85BEF85950665A0F462C9ADAD48717D19F456D8F0ADC18B028C4C39B3EAE5447DF262AC2C1FC949437CDA1579D3A081124801C39BDEA38B7D86259B81AD17E299D1C6A7CE6DE5C394BE0297E57A5436948A807E908F78A3950704440490BB63CFDCC84AA506E032AF54AD933E65EC98B507D8651E551E31242E6130781E4BE4101C29511E365D16E4DEA048B119EE94B9D4F4721093D72D3E98289804219121762F945BE0A6D196A3C55595C90433C623054309A7BB6329267CB78343AFEEDE3371A5406EBA7A8F3B199799112A5B84FEB8EECCBEA40BFC2D7DB3D1020D855493BE776AF212719054CABD4AA8F6E7ABEC104D3C82F86F16DD906FC7552510523C951A79D4F67A9833E96DD960D39764AE6E472CE54384454C072693DA4110BCBAB7A4B871D924328B31E53B55A58BF669BD0380F96BE52C56BC71C91D31CE02F9E72E5473192B28F052AB41BE4615F808C525D791BADF605CB5E467569AD00D6A8F5D81191A5A768E784A480F739B8948E0464975DE5015EF2844C83AA4A089826EDC9190DF6D7CD39046EE3A883CBA109C447EC97A901674C0AC72E1A7C04541D324928BF493810D844239D7B5E74D254587D19199676D3365B8CC501376A7CA843E713552585900ABC73B49A2EB2ED387A74CAE423E2648A6AABA8027A5180422EDA3A9E4B0D950626566F3578F0220AFAD787EB9B315CF03C862D5CF12E84D58A3A1704044570B209749F61B3ABD3AD692E3421FF86B2E6D2E29437EE283E9EE21C886576530B6E7FAD1AC04AAD6B67741CD90AFD75C18998CE1AFB9FB32C4B910CF61AB80D6F12C88CC463B40734868AC74BAE1793071EF9F98A646C832023BA3B0C3798909C17DDA5E969BFEDA01E492B94E581595E2BA3C298D159AC20DAAD4B44D7E79B51E6791802D4B12025DE3344247A083F8D9FF1CC7C146EFD81D6F72A13DDD08494914D10C0B5DA7372EEBBAD4EF4E61B008A188A125FB2C8729E06C473F5A04214C1FD8048870575192F1B4D6D1A129F83EF85AD230AEABFC2891286BC9FA92999C69C73733DA9C54836907DD1EAB962001F90826EC01AADB0A88736816F36F689B005442234DF407BD062479EAD72CD0711F916261708426C91B10AC05E36D02494D280D037A1F202CA4F0C32A168B593B0021BE4AAB739391735FF3C1A572B261243A527CB2157919B8421FD256DA59597B0E390B8D6E901EFE98863EB09FA32F7239348087BA399E892262E9ACCD86A209BC4B8F86E56EEDAB181DC70C9AD355551E284DB2EAFF537051D7B588741B1D3A3550CD0A352F30C91D147F723C3B392F52ECE773D0B6835B19403880CC5CE2CDF182029042FD57ADC39A09154141951265088A1521150A5685A502AA968929195269A9502A54298588522512026690450055108120A4448A96A488404609051A6916468422000801544211015515A0559049922468984112AA408195406890A440405564604989A2829021A16410952A10865495098A2691042601224016216249865460A88A150448858855898A41240646495546A09A16694850210628A808259A02182A19494964A2954588594526465229184240805A2665298A546A8A419A18009216008A69698A94504A96481B4329D3444151C0280B344949328953B84DD9A04813A141E2944553262193262D9B16511BB64C6094849A244988C428D1B6709A905149864984380911A7254A386D5984258A16298A222893A24CCAC22CA216441B946C81A46D11146952264494182D502229D9B26C4AA809CA044A93A46D514421C0986884A8280C876DDB42298CA224CA94891123649BA26C89263192B66953C60991424D198368CAB68CD9262810A66991B4695B362C9202651BC5684AA22C193924D9C644394D1695059DFF40AE256C5D5EDABFB69F5F40F37A588F50532CA408A8168AB1"
};
static const char *hex_sm_vec[] = {
    "1040212C00C2A0C4085004480C00100401D1903630100E8A080208903A40900176E974511AC9924773943661D80B805745DEE3A8A04BEB88AAC6ABF5C40995F9402E9A2339A9C8CCE0BF5AC4CA16D1427FEB7A838E2ED36208D61DEDB92D259A28E820ECF00668C246F24DC677E53F303C845F274A13BF92DEA978D1AB47064840BF76DBB373AAAE074BF131DDABF3165152CC04B8538D4EB392AB51E01AA793D581AB8641E86DBCDA1890EB83A99CD776398CE8F5FF9CCDFDC57A0CC8B90828E9A8C3B0C5CEBD33F1EB866DD129D6F9BBD2CF998DACF425C6895E9B31F4BE8475F3BF99BFC159AC08F894FCFEB63079E5B6BBAED8CA04C7D6A7BB05098725A9FF0BCF96B7539DE8FE3F89FDDF59A9D492973727F760A259CD08BDB1FD6DCB61EEA03217748EFEECDB72BD852DC3B48CFAEE25C20DA3F53ABB951534680616E0DC9C9186CD6AA67D7C4BBFA2055B2BA36C03B50BC3CA7077579D873E84675EAC538E09B52752C8E54EC01BFD06BABB9DD414CBFC09F71D6046CEFA0BB146236CC325D53E9DBBA85B5C1F7486F774DBEFE8CCC965751E99D26B1FAD0C4FBA30E844BF17C307D8C583CA9CF0BB7E58F42FB3D09B6597C93657ADDF06E255A9326DDCE54D93BA1BCF525FEAABCDA53BC221CB28EE451BA1EFB37F882C96DC8EFCFAF65E32AA524592B8C7466E6369F297CDBAE7AD79414F4D239281557F698A5A232C596ED481FEB34B6DBE9CCE002D96800EF64675C4220A4BBD14F9E4B3785295134261ACE81F5BCFEFCF351C08D8B24121E804A7F35EB5F1702D036056A1EF9C6D681443F8D760CC32F9015A1909C18D05E5ECFF8B517759714C7C88D9A57FB9B3F5C9BEB777D352B8CE01E24AD779AFE76176A34336A21A6E2868F04C8DCE69CAE7F302FA1055E2C722BA4492B1EE87F520BEA2CA39FD380613A82273AD421F326F002F7C1ADD8DF8F1C1FEB0F78DE92198CA22271FDB35CA296900E624985C8686E8B57DADC8EF2329C1B8B791373A7E3AA0269F1B5DB79E5721543EF1CCC19762245326B53F70E59739F7E9500766DF688A3C8DA6B40B0CDE0D54E2018D6598A111D788926F5A7DD23BBF577CAE6CF2D8DB4B75D25EBCC4D657804D847F0C9B71DBDB7C9AC88154AC81E3D059EA46FFBB696091ED4805513D3BED7EB4D57E9F637F6EC62CDD196C886379B3D0908223F9EE1D89FEBB5A0253C5E60147E5EF03F4D03042090C9696640F1690772DC8F00BF339DFD50922CDB53E0F5973D228E1F232263725F982AED3DE18D9218490C18BEF06C3C2CA967BBF4348FA05ECB3D775A356B23FC5FE5CD90FFCD1798A443DF59F8CF7CA319FB217100CEB205E28C28D4526EA7E58DFC5E2CCB3370F6D7BD1B78161F20138879DB6CFF67126B00D8315B845B890E8B0C25B9C87C371A79DC515AC39256B3242DC3848D36DBFBB5721860FD9F53CDC05A270352B5F7314FC2CAB919D80D74DCFE1DC1F6DD939FE5F8E818CC939347E942F30231211BBABB26C261CD3AEFB91895C451E6F6EDEC5AAF08C5FE677D3A6A1C6D0BDD5E0D5E66C0A352336300A2A3A343E1B45B8F8B1EDED39FADF15797AF507340CD212ADEC2F99C9DB66600A35E92F69175366B02E153E8F6F5874C78A08898779E08849C9AE9421ABC87FA9EC9CA6832F2EF4499560040B43F9EAF81022A30A2EA6A9E136AD1FC74665B4D7B63C721722119B0376FAC68EE1DB57DAECE1B8E5B05D8977BDA160382A8EF7ABD36BB591F6E860A482CC3583DD95108F6C0332D915479AD60F0E11E7A7F88976C9A6FF54F7E5D35EDF6C2F14AD346443E440D0E3361BF8E3D828F2E94A2F0196D7796D74FED15AFB8717067D9AA9EC9F7F8EB308E0B1827BA3BA6A6AEBCC4F807C2365FA0CABEF8F2E33D3335B44F88E82C98E2C0F323C984C28ED8104FF3C1CE8BB7B45855133B5795915320DE145B12D764F082A597127583EF2C31F6D1A7501084FE2B7A9A997F22396366108ED6C8DAE0085AB0733FE7004A9DD7EA6DFEED8061B1DB7915D4BBC40208DDA95A6CE82E9EE054128EDD8E93AE4B3014EAB53EEB6714618EA000000000000D81C4D8D734FCBFBEADE3D3F8A039FAA2A2C9957E835AD55B22E75BF57BB556AC8"
};

int axiocrypto_pqc_haetae2_kat(void)
{
    int ret = -1;
    size_t i;
    size_t failures = 0;

    const size_t n_pk  = ARRAY_LEN(hex_pk_vec);
    const size_t n_sk  = ARRAY_LEN(hex_sk_vec);
    const size_t n_msg = ARRAY_LEN(hex_msg_vec);
    const size_t n_sm  = ARRAY_LEN(hex_sm_vec);

    uint8_t *pk = NULL, *sk = NULL, *msg = NULL, *sm = NULL;
    uint8_t *out_signed = NULL, *recovered = NULL;

    size_t msg_len = 0;
    size_t sm_len = 0;
    size_t recovered_len = 0;
    size_t out_signed_len = 0;

    const size_t out_signed_buf_len = (size_t)PQC_MSG_MAX_SIZE
                                    + (size_t)PQC_HAETAE2_SIGNATURE_SIZE
                                    + 1024;

    printf("================================================================================\n");

    /* 배열 정합성 체크 */
    if (n_pk == 0 || n_pk != n_sk || n_pk != n_msg || n_pk != n_sm) {
        printf("FAIL [INIT] vector count mismatch: pk=%u sk=%u msg=%u sm=%u\n",
               (unsigned)n_pk, (unsigned)n_sk, (unsigned)n_msg, (unsigned)n_sm);
        return -1;
    }

    pk = (uint8_t*)malloc(PQC_HAETAE2_PUBLICKEY_SIZE);
    if (!pk) { printf("FAIL [INIT] pk malloc failed\n"); goto cleanup; }

    sk = (uint8_t*)malloc(PQC_HAETAE2_SECRETKEY_SIZE);
    if (!sk) { printf("FAIL [INIT] sk malloc failed\n"); goto cleanup; }

    msg = (uint8_t*)malloc(PQC_MSG_MAX_SIZE);
    if (!msg) { printf("FAIL [INIT] msg malloc failed\n"); goto cleanup; }

    sm = (uint8_t*)malloc(out_signed_buf_len);
    if (!sm) { printf("FAIL [INIT] sm malloc failed\n"); goto cleanup; }

    out_signed = (uint8_t*)malloc(out_signed_buf_len);
    if (!out_signed) { printf("FAIL [INIT] out_signed malloc failed\n"); goto cleanup; }

    recovered = (uint8_t*)malloc(PQC_MSG_MAX_SIZE);
    if (!recovered) { printf("FAIL [INIT] recovered malloc failed\n"); goto cleanup; }

    for (i = 0; i < n_pk; i++) {
        /* 출력 버퍼 초기화 */
        memset(pk, 0, PQC_HAETAE2_PUBLICKEY_SIZE);
        memset(sk, 0, PQC_HAETAE2_SECRETKEY_SIZE);
        memset(msg, 0, PQC_MSG_MAX_SIZE);
        memset(sm, 0, out_signed_buf_len);
        memset(out_signed, 0, out_signed_buf_len);
        memset(recovered, 0, PQC_MSG_MAX_SIZE);

        msg_len = 0;
        sm_len = 0;

        /* 벡터 파싱 */
        if (hexTobin(hex_pk_vec[i], pk, PQC_HAETAE2_PUBLICKEY_SIZE) != (int)PQC_HAETAE2_PUBLICKEY_SIZE) {
            printf("FAIL [#%02u][INIT] pk hex parse/size mismatch\n", (unsigned)i);
            failures++;
            continue;
        }

        if (hexTobin(hex_sk_vec[i], sk, PQC_HAETAE2_SECRETKEY_SIZE) != (int)PQC_HAETAE2_SECRETKEY_SIZE) {
            printf("FAIL [#%02u][INIT] sk hex parse/size mismatch\n", (unsigned)i);
            failures++;
            continue;
        }

        msg_len = strlen(hex_msg_vec[i]) / 2;
        if (msg_len > PQC_MSG_MAX_SIZE) {
            printf("FAIL [#%02u][INIT] msg too large: %u bytes (max %u)\n",
                   (unsigned)i, (unsigned)msg_len, (unsigned)PQC_MSG_MAX_SIZE);
            failures++;
            continue;
        }
        if (hexTobin(hex_msg_vec[i], msg, msg_len) != (int)msg_len) {
            printf("FAIL [#%02u][INIT] msg hex parse/size mismatch\n", (unsigned)i);
            failures++;
            continue;
        }

        sm_len = strlen(hex_sm_vec[i]) / 2;
        if (sm_len > out_signed_buf_len) {
            printf("FAIL [#%02u][INIT] sm too large: %u bytes (buf %u)\n",
                   (unsigned)i, (unsigned)sm_len, (unsigned)out_signed_buf_len);
            failures++;
            continue;
        }
        if (hexTobin(hex_sm_vec[i], sm, sm_len) != (int)sm_len) {
            printf("FAIL [#%02u][INIT] sm hex parse/size mismatch\n", (unsigned)i);
            failures++;
            continue;
        }

        /* ---- [VEC] open(pk_vec, sm_vec) => recovered == msg_vec ---- */
        printf("[#%02u][VEC] open(provided PK, provided SM) matches provided MSG..............", (unsigned)i);

        recovered_len = PQC_MSG_MAX_SIZE;
        ret = axiocrypto_pqc_open(PQC_HAETAE2,
                                  pk, PQC_HAETAE2_PUBLICKEY_SIZE,
                                  sm, sm_len,
                                  recovered, &recovered_len);
        if (ret != PQC_SUCCESS) {
            printf("FAIL (open ret=%d)\n", ret);
            failures++;
            continue;
        }
        if (recovered_len != msg_len || memcmp(recovered, msg, msg_len) != 0) {
            printf("FAIL (recovered message mismatch)\n");
            failures++;
            continue;
        }
        printf("PASS\n");

        /* ---- [RT] sign(sk_vec, msg_vec) -> open(pk_vec, out_signed) ---- */
        printf("[#%02u][RT ] sign(provided SK, provided MSG) then open(provided PK) matches...", (unsigned)i);

        out_signed_len = out_signed_buf_len;
        ret = axiocrypto_pqc_sign(PQC_HAETAE2,
                                  sk, PQC_HAETAE2_SECRETKEY_SIZE,
                                  msg, msg_len,
                                  out_signed, &out_signed_len);
        if (ret != PQC_SUCCESS) {
            printf("FAIL (sign ret=%d)\n", ret);
            failures++;
            continue;
        }

        recovered_len = PQC_MSG_MAX_SIZE;
        ret = axiocrypto_pqc_open(PQC_HAETAE2,
                                  pk, PQC_HAETAE2_PUBLICKEY_SIZE,
                                  out_signed, out_signed_len,
                                  recovered, &recovered_len);
        if (ret != PQC_SUCCESS) {
            printf("FAIL (open ret=%d)\n", ret);
            failures++;
            continue;
        }
        if (recovered_len != msg_len || memcmp(recovered, msg, msg_len) != 0) {
            printf("FAIL (round-trip recovered message mismatch)\n");
            failures++;
            continue;
        }
        printf("PASS\n");
    }

    if (failures == 0) {
        printf("RESULT: SUCCESS (%u/%u passed)\n", (unsigned)n_pk, (unsigned)n_pk);
        ret = 0;
    } else {
        printf("RESULT: FAILED (%u/%u failed)\n", (unsigned)failures, (unsigned)n_pk);
        ret = -1;
    }
    printf("================================================================================\n\n");

cleanup:
    if (pk) free(pk);
    if (sk) free(sk);
    if (msg) free(msg);
    if (sm) free(sm);
    if (out_signed) free(out_signed);
    if (recovered) free(recovered);

    return ret;
}

void axiocrypto_pqc_haetae2_bench()
{
    int ret = 0;

    uint8_t pk[PQC_HAETAE2_PUBLICKEY_SIZE] = {0x00,};
    uint8_t sk[PQC_HAETAE2_SECRETKEY_SIZE] = {0x00,};
    uint8_t sig[PQC_HAETAE2_SIGNATURE_SIZE] = {0x00,};
    size_t siglen = PQC_HAETAE2_SIGNATURE_SIZE;
    uint8_t msg[PQC_MSG_MAX_SIZE] = {0x00,};
    size_t msglen = PQC_MSG_MAX_SIZE;

    TickType_t s, e;
    
    printf("(op=%d, msglen=%d)\n", NTESTS, (int)msglen);
    printf("============================================================\n");
    secure_stack_init();
    s = xTaskGetTickCount();
    for(int i = 0; i < NTESTS; i++){
        ret = axiocrypto_pqc_keypair(PQC_HAETAE2, pk, PQC_HAETAE2_PUBLICKEY_SIZE, sk, PQC_HAETAE2_SECRETKEY_SIZE);
        if(ret != PQC_SUCCESS){
            printf("HAETAE2 keypair generation failed(ret:%d)\n", ret);
            return;
        }
    }
    e = xTaskGetTickCount();
    printf("KeyGen:\t");
    print_elapsed_ms_ticks(s, e, NTESTS);
    printf(" | ");
    secure_stack_disp();

    secure_stack_init();
    s = xTaskGetTickCount();
    for(int i = 0; i < NTESTS; i++){
        ret = axiocrypto_pqc_sign_signature(PQC_HAETAE2, sk, PQC_HAETAE2_SECRETKEY_SIZE, msg, msglen, sig, &siglen);
        if(ret != PQC_SUCCESS){
            printf("HAETAE2 signing failed(ret:%d)\n", ret);
            return;
        }
    }
    e = xTaskGetTickCount();
    printf("Sign:\t");
    print_elapsed_ms_ticks(s, e, NTESTS);
    printf(" | ");
    secure_stack_disp();

    secure_stack_init();
    s = xTaskGetTickCount();
    for(int i = 0; i < NTESTS; i++){
        ret = axiocrypto_pqc_verify(PQC_HAETAE2, pk, PQC_HAETAE2_PUBLICKEY_SIZE, msg, msglen, sig, siglen);
        if(ret != PQC_SUCCESS){
            printf("HAETAE2 signature verification failed(ret:%d)\n", ret);
            return;
        }
    }
    e = xTaskGetTickCount();
    printf("Verify:\t");
    print_elapsed_ms_ticks(s, e, NTESTS);
    printf(" | ");
    secure_stack_disp();
    printf("============================================================\n\n");

    return;
}
